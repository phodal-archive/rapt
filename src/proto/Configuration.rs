// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `Configuration.proto`

use protobuf::{ProtobufEnum, Message};

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Configuration {
    // message fields
    pub mcc: u32,
    pub mnc: u32,
    pub locale: ::std::string::String,
    pub layout_direction: Configuration_LayoutDirection,
    pub screen_width: u32,
    pub screen_height: u32,
    pub screen_width_dp: u32,
    pub screen_height_dp: u32,
    pub smallest_screen_width_dp: u32,
    pub screen_layout_size: Configuration_ScreenLayoutSize,
    pub screen_layout_long: Configuration_ScreenLayoutLong,
    pub screen_round: Configuration_ScreenRound,
    pub wide_color_gamut: Configuration_WideColorGamut,
    pub hdr: Configuration_Hdr,
    pub orientation: Configuration_Orientation,
    pub ui_mode_type: Configuration_UiModeType,
    pub ui_mode_night: Configuration_UiModeNight,
    pub density: u32,
    pub touchscreen: Configuration_Touchscreen,
    pub keys_hidden: Configuration_KeysHidden,
    pub keyboard: Configuration_Keyboard,
    pub nav_hidden: Configuration_NavHidden,
    pub navigation: Configuration_Navigation,
    pub sdk_version: u32,
    pub product: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Configuration {
    fn default() -> &'a Configuration {
        <Configuration as ::protobuf::Message>::default_instance()
    }
}

impl Configuration {
    pub fn new() -> Configuration {
        ::std::default::Default::default()
    }

    // uint32 mcc = 1;


    pub fn get_mcc(&self) -> u32 {
        self.mcc
    }
    pub fn clear_mcc(&mut self) {
        self.mcc = 0;
    }

    // Param is passed by value, moved
    pub fn set_mcc(&mut self, v: u32) {
        self.mcc = v;
    }

    // uint32 mnc = 2;


    pub fn get_mnc(&self) -> u32 {
        self.mnc
    }
    pub fn clear_mnc(&mut self) {
        self.mnc = 0;
    }

    // Param is passed by value, moved
    pub fn set_mnc(&mut self, v: u32) {
        self.mnc = v;
    }

    // string locale = 3;


    pub fn get_locale(&self) -> &str {
        &self.locale
    }
    pub fn clear_locale(&mut self) {
        self.locale.clear();
    }

    // Param is passed by value, moved
    pub fn set_locale(&mut self, v: ::std::string::String) {
        self.locale = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locale(&mut self) -> &mut ::std::string::String {
        &mut self.locale
    }

    // Take field
    pub fn take_locale(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.locale, ::std::string::String::new())
    }

    // .aapt.pb.Configuration.LayoutDirection layout_direction = 4;


    pub fn get_layout_direction(&self) -> Configuration_LayoutDirection {
        self.layout_direction
    }
    pub fn clear_layout_direction(&mut self) {
        self.layout_direction = Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_layout_direction(&mut self, v: Configuration_LayoutDirection) {
        self.layout_direction = v;
    }

    // uint32 screen_width = 5;


    pub fn get_screen_width(&self) -> u32 {
        self.screen_width
    }
    pub fn clear_screen_width(&mut self) {
        self.screen_width = 0;
    }

    // Param is passed by value, moved
    pub fn set_screen_width(&mut self, v: u32) {
        self.screen_width = v;
    }

    // uint32 screen_height = 6;


    pub fn get_screen_height(&self) -> u32 {
        self.screen_height
    }
    pub fn clear_screen_height(&mut self) {
        self.screen_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_screen_height(&mut self, v: u32) {
        self.screen_height = v;
    }

    // uint32 screen_width_dp = 7;


    pub fn get_screen_width_dp(&self) -> u32 {
        self.screen_width_dp
    }
    pub fn clear_screen_width_dp(&mut self) {
        self.screen_width_dp = 0;
    }

    // Param is passed by value, moved
    pub fn set_screen_width_dp(&mut self, v: u32) {
        self.screen_width_dp = v;
    }

    // uint32 screen_height_dp = 8;


    pub fn get_screen_height_dp(&self) -> u32 {
        self.screen_height_dp
    }
    pub fn clear_screen_height_dp(&mut self) {
        self.screen_height_dp = 0;
    }

    // Param is passed by value, moved
    pub fn set_screen_height_dp(&mut self, v: u32) {
        self.screen_height_dp = v;
    }

    // uint32 smallest_screen_width_dp = 9;


    pub fn get_smallest_screen_width_dp(&self) -> u32 {
        self.smallest_screen_width_dp
    }
    pub fn clear_smallest_screen_width_dp(&mut self) {
        self.smallest_screen_width_dp = 0;
    }

    // Param is passed by value, moved
    pub fn set_smallest_screen_width_dp(&mut self, v: u32) {
        self.smallest_screen_width_dp = v;
    }

    // .aapt.pb.Configuration.ScreenLayoutSize screen_layout_size = 10;


    pub fn get_screen_layout_size(&self) -> Configuration_ScreenLayoutSize {
        self.screen_layout_size
    }
    pub fn clear_screen_layout_size(&mut self) {
        self.screen_layout_size = Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_screen_layout_size(&mut self, v: Configuration_ScreenLayoutSize) {
        self.screen_layout_size = v;
    }

    // .aapt.pb.Configuration.ScreenLayoutLong screen_layout_long = 11;


    pub fn get_screen_layout_long(&self) -> Configuration_ScreenLayoutLong {
        self.screen_layout_long
    }
    pub fn clear_screen_layout_long(&mut self) {
        self.screen_layout_long = Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_screen_layout_long(&mut self, v: Configuration_ScreenLayoutLong) {
        self.screen_layout_long = v;
    }

    // .aapt.pb.Configuration.ScreenRound screen_round = 12;


    pub fn get_screen_round(&self) -> Configuration_ScreenRound {
        self.screen_round
    }
    pub fn clear_screen_round(&mut self) {
        self.screen_round = Configuration_ScreenRound::SCREEN_ROUND_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_screen_round(&mut self, v: Configuration_ScreenRound) {
        self.screen_round = v;
    }

    // .aapt.pb.Configuration.WideColorGamut wide_color_gamut = 13;


    pub fn get_wide_color_gamut(&self) -> Configuration_WideColorGamut {
        self.wide_color_gamut
    }
    pub fn clear_wide_color_gamut(&mut self) {
        self.wide_color_gamut = Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_wide_color_gamut(&mut self, v: Configuration_WideColorGamut) {
        self.wide_color_gamut = v;
    }

    // .aapt.pb.Configuration.Hdr hdr = 14;


    pub fn get_hdr(&self) -> Configuration_Hdr {
        self.hdr
    }
    pub fn clear_hdr(&mut self) {
        self.hdr = Configuration_Hdr::HDR_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_hdr(&mut self, v: Configuration_Hdr) {
        self.hdr = v;
    }

    // .aapt.pb.Configuration.Orientation orientation = 15;


    pub fn get_orientation(&self) -> Configuration_Orientation {
        self.orientation
    }
    pub fn clear_orientation(&mut self) {
        self.orientation = Configuration_Orientation::ORIENTATION_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_orientation(&mut self, v: Configuration_Orientation) {
        self.orientation = v;
    }

    // .aapt.pb.Configuration.UiModeType ui_mode_type = 16;


    pub fn get_ui_mode_type(&self) -> Configuration_UiModeType {
        self.ui_mode_type
    }
    pub fn clear_ui_mode_type(&mut self) {
        self.ui_mode_type = Configuration_UiModeType::UI_MODE_TYPE_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_ui_mode_type(&mut self, v: Configuration_UiModeType) {
        self.ui_mode_type = v;
    }

    // .aapt.pb.Configuration.UiModeNight ui_mode_night = 17;


    pub fn get_ui_mode_night(&self) -> Configuration_UiModeNight {
        self.ui_mode_night
    }
    pub fn clear_ui_mode_night(&mut self) {
        self.ui_mode_night = Configuration_UiModeNight::UI_MODE_NIGHT_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_ui_mode_night(&mut self, v: Configuration_UiModeNight) {
        self.ui_mode_night = v;
    }

    // uint32 density = 18;


    pub fn get_density(&self) -> u32 {
        self.density
    }
    pub fn clear_density(&mut self) {
        self.density = 0;
    }

    // Param is passed by value, moved
    pub fn set_density(&mut self, v: u32) {
        self.density = v;
    }

    // .aapt.pb.Configuration.Touchscreen touchscreen = 19;


    pub fn get_touchscreen(&self) -> Configuration_Touchscreen {
        self.touchscreen
    }
    pub fn clear_touchscreen(&mut self) {
        self.touchscreen = Configuration_Touchscreen::TOUCHSCREEN_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_touchscreen(&mut self, v: Configuration_Touchscreen) {
        self.touchscreen = v;
    }

    // .aapt.pb.Configuration.KeysHidden keys_hidden = 20;


    pub fn get_keys_hidden(&self) -> Configuration_KeysHidden {
        self.keys_hidden
    }
    pub fn clear_keys_hidden(&mut self) {
        self.keys_hidden = Configuration_KeysHidden::KEYS_HIDDEN_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_keys_hidden(&mut self, v: Configuration_KeysHidden) {
        self.keys_hidden = v;
    }

    // .aapt.pb.Configuration.Keyboard keyboard = 21;


    pub fn get_keyboard(&self) -> Configuration_Keyboard {
        self.keyboard
    }
    pub fn clear_keyboard(&mut self) {
        self.keyboard = Configuration_Keyboard::KEYBOARD_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_keyboard(&mut self, v: Configuration_Keyboard) {
        self.keyboard = v;
    }

    // .aapt.pb.Configuration.NavHidden nav_hidden = 22;


    pub fn get_nav_hidden(&self) -> Configuration_NavHidden {
        self.nav_hidden
    }
    pub fn clear_nav_hidden(&mut self) {
        self.nav_hidden = Configuration_NavHidden::NAV_HIDDEN_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_nav_hidden(&mut self, v: Configuration_NavHidden) {
        self.nav_hidden = v;
    }

    // .aapt.pb.Configuration.Navigation navigation = 23;


    pub fn get_navigation(&self) -> Configuration_Navigation {
        self.navigation
    }
    pub fn clear_navigation(&mut self) {
        self.navigation = Configuration_Navigation::NAVIGATION_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_navigation(&mut self, v: Configuration_Navigation) {
        self.navigation = v;
    }

    // uint32 sdk_version = 24;


    pub fn get_sdk_version(&self) -> u32 {
        self.sdk_version
    }
    pub fn clear_sdk_version(&mut self) {
        self.sdk_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_sdk_version(&mut self, v: u32) {
        self.sdk_version = v;
    }

    // string product = 25;


    pub fn get_product(&self) -> &str {
        &self.product
    }
    pub fn clear_product(&mut self) {
        self.product.clear();
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        &mut self.product
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Configuration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mcc = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mnc = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.locale)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.layout_direction, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.screen_width = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.screen_height = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.screen_width_dp = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.screen_height_dp = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.smallest_screen_width_dp = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.screen_layout_size, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.screen_layout_long, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.screen_round, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.wide_color_gamut, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.hdr, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.orientation, 15, &mut self.unknown_fields)?
                },
                16 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ui_mode_type, 16, &mut self.unknown_fields)?
                },
                17 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.ui_mode_night, 17, &mut self.unknown_fields)?
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.density = tmp;
                },
                19 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.touchscreen, 19, &mut self.unknown_fields)?
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.keys_hidden, 20, &mut self.unknown_fields)?
                },
                21 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.keyboard, 21, &mut self.unknown_fields)?
                },
                22 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.nav_hidden, 22, &mut self.unknown_fields)?
                },
                23 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.navigation, 23, &mut self.unknown_fields)?
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sdk_version = tmp;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mcc != 0 {
            my_size += ::protobuf::rt::value_size(1, self.mcc, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mnc != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mnc, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.locale.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.locale);
        }
        if self.layout_direction != Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET {
            my_size += ::protobuf::rt::enum_size(4, self.layout_direction);
        }
        if self.screen_width != 0 {
            my_size += ::protobuf::rt::value_size(5, self.screen_width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.screen_height != 0 {
            my_size += ::protobuf::rt::value_size(6, self.screen_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.screen_width_dp != 0 {
            my_size += ::protobuf::rt::value_size(7, self.screen_width_dp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.screen_height_dp != 0 {
            my_size += ::protobuf::rt::value_size(8, self.screen_height_dp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.smallest_screen_width_dp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.smallest_screen_width_dp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.screen_layout_size != Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET {
            my_size += ::protobuf::rt::enum_size(10, self.screen_layout_size);
        }
        if self.screen_layout_long != Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET {
            my_size += ::protobuf::rt::enum_size(11, self.screen_layout_long);
        }
        if self.screen_round != Configuration_ScreenRound::SCREEN_ROUND_UNSET {
            my_size += ::protobuf::rt::enum_size(12, self.screen_round);
        }
        if self.wide_color_gamut != Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET {
            my_size += ::protobuf::rt::enum_size(13, self.wide_color_gamut);
        }
        if self.hdr != Configuration_Hdr::HDR_UNSET {
            my_size += ::protobuf::rt::enum_size(14, self.hdr);
        }
        if self.orientation != Configuration_Orientation::ORIENTATION_UNSET {
            my_size += ::protobuf::rt::enum_size(15, self.orientation);
        }
        if self.ui_mode_type != Configuration_UiModeType::UI_MODE_TYPE_UNSET {
            my_size += ::protobuf::rt::enum_size(16, self.ui_mode_type);
        }
        if self.ui_mode_night != Configuration_UiModeNight::UI_MODE_NIGHT_UNSET {
            my_size += ::protobuf::rt::enum_size(17, self.ui_mode_night);
        }
        if self.density != 0 {
            my_size += ::protobuf::rt::value_size(18, self.density, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.touchscreen != Configuration_Touchscreen::TOUCHSCREEN_UNSET {
            my_size += ::protobuf::rt::enum_size(19, self.touchscreen);
        }
        if self.keys_hidden != Configuration_KeysHidden::KEYS_HIDDEN_UNSET {
            my_size += ::protobuf::rt::enum_size(20, self.keys_hidden);
        }
        if self.keyboard != Configuration_Keyboard::KEYBOARD_UNSET {
            my_size += ::protobuf::rt::enum_size(21, self.keyboard);
        }
        if self.nav_hidden != Configuration_NavHidden::NAV_HIDDEN_UNSET {
            my_size += ::protobuf::rt::enum_size(22, self.nav_hidden);
        }
        if self.navigation != Configuration_Navigation::NAVIGATION_UNSET {
            my_size += ::protobuf::rt::enum_size(23, self.navigation);
        }
        if self.sdk_version != 0 {
            my_size += ::protobuf::rt::value_size(24, self.sdk_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.product.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.product);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mcc != 0 {
            os.write_uint32(1, self.mcc)?;
        }
        if self.mnc != 0 {
            os.write_uint32(2, self.mnc)?;
        }
        if !self.locale.is_empty() {
            os.write_string(3, &self.locale)?;
        }
        if self.layout_direction != Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.layout_direction))?;
        }
        if self.screen_width != 0 {
            os.write_uint32(5, self.screen_width)?;
        }
        if self.screen_height != 0 {
            os.write_uint32(6, self.screen_height)?;
        }
        if self.screen_width_dp != 0 {
            os.write_uint32(7, self.screen_width_dp)?;
        }
        if self.screen_height_dp != 0 {
            os.write_uint32(8, self.screen_height_dp)?;
        }
        if self.smallest_screen_width_dp != 0 {
            os.write_uint32(9, self.smallest_screen_width_dp)?;
        }
        if self.screen_layout_size != Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.screen_layout_size))?;
        }
        if self.screen_layout_long != Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.screen_layout_long))?;
        }
        if self.screen_round != Configuration_ScreenRound::SCREEN_ROUND_UNSET {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.screen_round))?;
        }
        if self.wide_color_gamut != Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.wide_color_gamut))?;
        }
        if self.hdr != Configuration_Hdr::HDR_UNSET {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.hdr))?;
        }
        if self.orientation != Configuration_Orientation::ORIENTATION_UNSET {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&self.orientation))?;
        }
        if self.ui_mode_type != Configuration_UiModeType::UI_MODE_TYPE_UNSET {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(&self.ui_mode_type))?;
        }
        if self.ui_mode_night != Configuration_UiModeNight::UI_MODE_NIGHT_UNSET {
            os.write_enum(17, ::protobuf::ProtobufEnum::value(&self.ui_mode_night))?;
        }
        if self.density != 0 {
            os.write_uint32(18, self.density)?;
        }
        if self.touchscreen != Configuration_Touchscreen::TOUCHSCREEN_UNSET {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&self.touchscreen))?;
        }
        if self.keys_hidden != Configuration_KeysHidden::KEYS_HIDDEN_UNSET {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&self.keys_hidden))?;
        }
        if self.keyboard != Configuration_Keyboard::KEYBOARD_UNSET {
            os.write_enum(21, ::protobuf::ProtobufEnum::value(&self.keyboard))?;
        }
        if self.nav_hidden != Configuration_NavHidden::NAV_HIDDEN_UNSET {
            os.write_enum(22, ::protobuf::ProtobufEnum::value(&self.nav_hidden))?;
        }
        if self.navigation != Configuration_Navigation::NAVIGATION_UNSET {
            os.write_enum(23, ::protobuf::ProtobufEnum::value(&self.navigation))?;
        }
        if self.sdk_version != 0 {
            os.write_uint32(24, self.sdk_version)?;
        }
        if !self.product.is_empty() {
            os.write_string(25, &self.product)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Configuration {
        Configuration::new()
    }

    fn default_instance() -> &'static Configuration {
        static instance: ::protobuf::rt::LazyV2<Configuration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Configuration::new)
    }
}

impl ::protobuf::Clear for Configuration {
    fn clear(&mut self) {
        self.mcc = 0;
        self.mnc = 0;
        self.locale.clear();
        self.layout_direction = Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET;
        self.screen_width = 0;
        self.screen_height = 0;
        self.screen_width_dp = 0;
        self.screen_height_dp = 0;
        self.smallest_screen_width_dp = 0;
        self.screen_layout_size = Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET;
        self.screen_layout_long = Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET;
        self.screen_round = Configuration_ScreenRound::SCREEN_ROUND_UNSET;
        self.wide_color_gamut = Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET;
        self.hdr = Configuration_Hdr::HDR_UNSET;
        self.orientation = Configuration_Orientation::ORIENTATION_UNSET;
        self.ui_mode_type = Configuration_UiModeType::UI_MODE_TYPE_UNSET;
        self.ui_mode_night = Configuration_UiModeNight::UI_MODE_NIGHT_UNSET;
        self.density = 0;
        self.touchscreen = Configuration_Touchscreen::TOUCHSCREEN_UNSET;
        self.keys_hidden = Configuration_KeysHidden::KEYS_HIDDEN_UNSET;
        self.keyboard = Configuration_Keyboard::KEYBOARD_UNSET;
        self.nav_hidden = Configuration_NavHidden::NAV_HIDDEN_UNSET;
        self.navigation = Configuration_Navigation::NAVIGATION_UNSET;
        self.sdk_version = 0;
        self.product.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_LayoutDirection {
    LAYOUT_DIRECTION_UNSET = 0,
    LAYOUT_DIRECTION_LTR = 1,
    LAYOUT_DIRECTION_RTL = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_LayoutDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_LayoutDirection> {
        match value {
            0 => ::std::option::Option::Some(Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET),
            1 => ::std::option::Option::Some(Configuration_LayoutDirection::LAYOUT_DIRECTION_LTR),
            2 => ::std::option::Option::Some(Configuration_LayoutDirection::LAYOUT_DIRECTION_RTL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_LayoutDirection] = &[
            Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET,
            Configuration_LayoutDirection::LAYOUT_DIRECTION_LTR,
            Configuration_LayoutDirection::LAYOUT_DIRECTION_RTL,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_LayoutDirection {
}

impl ::std::default::Default for Configuration_LayoutDirection {
    fn default() -> Self {
        Configuration_LayoutDirection::LAYOUT_DIRECTION_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_LayoutDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_ScreenLayoutSize {
    SCREEN_LAYOUT_SIZE_UNSET = 0,
    SCREEN_LAYOUT_SIZE_SMALL = 1,
    SCREEN_LAYOUT_SIZE_NORMAL = 2,
    SCREEN_LAYOUT_SIZE_LARGE = 3,
    SCREEN_LAYOUT_SIZE_XLARGE = 4,
}

impl ::protobuf::ProtobufEnum for Configuration_ScreenLayoutSize {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_ScreenLayoutSize> {
        match value {
            0 => ::std::option::Option::Some(Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET),
            1 => ::std::option::Option::Some(Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_SMALL),
            2 => ::std::option::Option::Some(Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_NORMAL),
            3 => ::std::option::Option::Some(Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_LARGE),
            4 => ::std::option::Option::Some(Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_XLARGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_ScreenLayoutSize] = &[
            Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET,
            Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_SMALL,
            Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_NORMAL,
            Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_LARGE,
            Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_XLARGE,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_ScreenLayoutSize {
}

impl ::std::default::Default for Configuration_ScreenLayoutSize {
    fn default() -> Self {
        Configuration_ScreenLayoutSize::SCREEN_LAYOUT_SIZE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_ScreenLayoutSize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_ScreenLayoutLong {
    SCREEN_LAYOUT_LONG_UNSET = 0,
    SCREEN_LAYOUT_LONG_LONG = 1,
    SCREEN_LAYOUT_LONG_NOTLONG = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_ScreenLayoutLong {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_ScreenLayoutLong> {
        match value {
            0 => ::std::option::Option::Some(Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET),
            1 => ::std::option::Option::Some(Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_LONG),
            2 => ::std::option::Option::Some(Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_NOTLONG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_ScreenLayoutLong] = &[
            Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET,
            Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_LONG,
            Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_NOTLONG,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_ScreenLayoutLong {
}

impl ::std::default::Default for Configuration_ScreenLayoutLong {
    fn default() -> Self {
        Configuration_ScreenLayoutLong::SCREEN_LAYOUT_LONG_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_ScreenLayoutLong {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_ScreenRound {
    SCREEN_ROUND_UNSET = 0,
    SCREEN_ROUND_ROUND = 1,
    SCREEN_ROUND_NOTROUND = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_ScreenRound {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_ScreenRound> {
        match value {
            0 => ::std::option::Option::Some(Configuration_ScreenRound::SCREEN_ROUND_UNSET),
            1 => ::std::option::Option::Some(Configuration_ScreenRound::SCREEN_ROUND_ROUND),
            2 => ::std::option::Option::Some(Configuration_ScreenRound::SCREEN_ROUND_NOTROUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_ScreenRound] = &[
            Configuration_ScreenRound::SCREEN_ROUND_UNSET,
            Configuration_ScreenRound::SCREEN_ROUND_ROUND,
            Configuration_ScreenRound::SCREEN_ROUND_NOTROUND,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_ScreenRound {
}

impl ::std::default::Default for Configuration_ScreenRound {
    fn default() -> Self {
        Configuration_ScreenRound::SCREEN_ROUND_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_ScreenRound {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_WideColorGamut {
    WIDE_COLOR_GAMUT_UNSET = 0,
    WIDE_COLOR_GAMUT_WIDECG = 1,
    WIDE_COLOR_GAMUT_NOWIDECG = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_WideColorGamut {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_WideColorGamut> {
        match value {
            0 => ::std::option::Option::Some(Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET),
            1 => ::std::option::Option::Some(Configuration_WideColorGamut::WIDE_COLOR_GAMUT_WIDECG),
            2 => ::std::option::Option::Some(Configuration_WideColorGamut::WIDE_COLOR_GAMUT_NOWIDECG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_WideColorGamut] = &[
            Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET,
            Configuration_WideColorGamut::WIDE_COLOR_GAMUT_WIDECG,
            Configuration_WideColorGamut::WIDE_COLOR_GAMUT_NOWIDECG,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_WideColorGamut {
}

impl ::std::default::Default for Configuration_WideColorGamut {
    fn default() -> Self {
        Configuration_WideColorGamut::WIDE_COLOR_GAMUT_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_WideColorGamut {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_Hdr {
    HDR_UNSET = 0,
    HDR_HIGHDR = 1,
    HDR_LOWDR = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_Hdr {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_Hdr> {
        match value {
            0 => ::std::option::Option::Some(Configuration_Hdr::HDR_UNSET),
            1 => ::std::option::Option::Some(Configuration_Hdr::HDR_HIGHDR),
            2 => ::std::option::Option::Some(Configuration_Hdr::HDR_LOWDR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_Hdr] = &[
            Configuration_Hdr::HDR_UNSET,
            Configuration_Hdr::HDR_HIGHDR,
            Configuration_Hdr::HDR_LOWDR,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_Hdr {
}

impl ::std::default::Default for Configuration_Hdr {
    fn default() -> Self {
        Configuration_Hdr::HDR_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_Hdr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_Orientation {
    ORIENTATION_UNSET = 0,
    ORIENTATION_PORT = 1,
    ORIENTATION_LAND = 2,
    ORIENTATION_SQUARE = 3,
}

impl ::protobuf::ProtobufEnum for Configuration_Orientation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_Orientation> {
        match value {
            0 => ::std::option::Option::Some(Configuration_Orientation::ORIENTATION_UNSET),
            1 => ::std::option::Option::Some(Configuration_Orientation::ORIENTATION_PORT),
            2 => ::std::option::Option::Some(Configuration_Orientation::ORIENTATION_LAND),
            3 => ::std::option::Option::Some(Configuration_Orientation::ORIENTATION_SQUARE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_Orientation] = &[
            Configuration_Orientation::ORIENTATION_UNSET,
            Configuration_Orientation::ORIENTATION_PORT,
            Configuration_Orientation::ORIENTATION_LAND,
            Configuration_Orientation::ORIENTATION_SQUARE,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_Orientation {
}

impl ::std::default::Default for Configuration_Orientation {
    fn default() -> Self {
        Configuration_Orientation::ORIENTATION_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_Orientation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_UiModeType {
    UI_MODE_TYPE_UNSET = 0,
    UI_MODE_TYPE_NORMAL = 1,
    UI_MODE_TYPE_DESK = 2,
    UI_MODE_TYPE_CAR = 3,
    UI_MODE_TYPE_TELEVISION = 4,
    UI_MODE_TYPE_APPLIANCE = 5,
    UI_MODE_TYPE_WATCH = 6,
    UI_MODE_TYPE_VRHEADSET = 7,
}

impl ::protobuf::ProtobufEnum for Configuration_UiModeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_UiModeType> {
        match value {
            0 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_UNSET),
            1 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_NORMAL),
            2 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_DESK),
            3 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_CAR),
            4 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_TELEVISION),
            5 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_APPLIANCE),
            6 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_WATCH),
            7 => ::std::option::Option::Some(Configuration_UiModeType::UI_MODE_TYPE_VRHEADSET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_UiModeType] = &[
            Configuration_UiModeType::UI_MODE_TYPE_UNSET,
            Configuration_UiModeType::UI_MODE_TYPE_NORMAL,
            Configuration_UiModeType::UI_MODE_TYPE_DESK,
            Configuration_UiModeType::UI_MODE_TYPE_CAR,
            Configuration_UiModeType::UI_MODE_TYPE_TELEVISION,
            Configuration_UiModeType::UI_MODE_TYPE_APPLIANCE,
            Configuration_UiModeType::UI_MODE_TYPE_WATCH,
            Configuration_UiModeType::UI_MODE_TYPE_VRHEADSET,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_UiModeType {
}

impl ::std::default::Default for Configuration_UiModeType {
    fn default() -> Self {
        Configuration_UiModeType::UI_MODE_TYPE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_UiModeType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_UiModeNight {
    UI_MODE_NIGHT_UNSET = 0,
    UI_MODE_NIGHT_NIGHT = 1,
    UI_MODE_NIGHT_NOTNIGHT = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_UiModeNight {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_UiModeNight> {
        match value {
            0 => ::std::option::Option::Some(Configuration_UiModeNight::UI_MODE_NIGHT_UNSET),
            1 => ::std::option::Option::Some(Configuration_UiModeNight::UI_MODE_NIGHT_NIGHT),
            2 => ::std::option::Option::Some(Configuration_UiModeNight::UI_MODE_NIGHT_NOTNIGHT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_UiModeNight] = &[
            Configuration_UiModeNight::UI_MODE_NIGHT_UNSET,
            Configuration_UiModeNight::UI_MODE_NIGHT_NIGHT,
            Configuration_UiModeNight::UI_MODE_NIGHT_NOTNIGHT,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_UiModeNight {
}

impl ::std::default::Default for Configuration_UiModeNight {
    fn default() -> Self {
        Configuration_UiModeNight::UI_MODE_NIGHT_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_UiModeNight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_Touchscreen {
    TOUCHSCREEN_UNSET = 0,
    TOUCHSCREEN_NOTOUCH = 1,
    TOUCHSCREEN_STYLUS = 2,
    TOUCHSCREEN_FINGER = 3,
}

impl ::protobuf::ProtobufEnum for Configuration_Touchscreen {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_Touchscreen> {
        match value {
            0 => ::std::option::Option::Some(Configuration_Touchscreen::TOUCHSCREEN_UNSET),
            1 => ::std::option::Option::Some(Configuration_Touchscreen::TOUCHSCREEN_NOTOUCH),
            2 => ::std::option::Option::Some(Configuration_Touchscreen::TOUCHSCREEN_STYLUS),
            3 => ::std::option::Option::Some(Configuration_Touchscreen::TOUCHSCREEN_FINGER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_Touchscreen] = &[
            Configuration_Touchscreen::TOUCHSCREEN_UNSET,
            Configuration_Touchscreen::TOUCHSCREEN_NOTOUCH,
            Configuration_Touchscreen::TOUCHSCREEN_STYLUS,
            Configuration_Touchscreen::TOUCHSCREEN_FINGER,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_Touchscreen {
}

impl ::std::default::Default for Configuration_Touchscreen {
    fn default() -> Self {
        Configuration_Touchscreen::TOUCHSCREEN_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_Touchscreen {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_KeysHidden {
    KEYS_HIDDEN_UNSET = 0,
    KEYS_HIDDEN_KEYSEXPOSED = 1,
    KEYS_HIDDEN_KEYSHIDDEN = 2,
    KEYS_HIDDEN_KEYSSOFT = 3,
}

impl ::protobuf::ProtobufEnum for Configuration_KeysHidden {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_KeysHidden> {
        match value {
            0 => ::std::option::Option::Some(Configuration_KeysHidden::KEYS_HIDDEN_UNSET),
            1 => ::std::option::Option::Some(Configuration_KeysHidden::KEYS_HIDDEN_KEYSEXPOSED),
            2 => ::std::option::Option::Some(Configuration_KeysHidden::KEYS_HIDDEN_KEYSHIDDEN),
            3 => ::std::option::Option::Some(Configuration_KeysHidden::KEYS_HIDDEN_KEYSSOFT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_KeysHidden] = &[
            Configuration_KeysHidden::KEYS_HIDDEN_UNSET,
            Configuration_KeysHidden::KEYS_HIDDEN_KEYSEXPOSED,
            Configuration_KeysHidden::KEYS_HIDDEN_KEYSHIDDEN,
            Configuration_KeysHidden::KEYS_HIDDEN_KEYSSOFT,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_KeysHidden {
}

impl ::std::default::Default for Configuration_KeysHidden {
    fn default() -> Self {
        Configuration_KeysHidden::KEYS_HIDDEN_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_KeysHidden {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_Keyboard {
    KEYBOARD_UNSET = 0,
    KEYBOARD_NOKEYS = 1,
    KEYBOARD_QWERTY = 2,
    KEYBOARD_TWELVEKEY = 3,
}

impl ::protobuf::ProtobufEnum for Configuration_Keyboard {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_Keyboard> {
        match value {
            0 => ::std::option::Option::Some(Configuration_Keyboard::KEYBOARD_UNSET),
            1 => ::std::option::Option::Some(Configuration_Keyboard::KEYBOARD_NOKEYS),
            2 => ::std::option::Option::Some(Configuration_Keyboard::KEYBOARD_QWERTY),
            3 => ::std::option::Option::Some(Configuration_Keyboard::KEYBOARD_TWELVEKEY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_Keyboard] = &[
            Configuration_Keyboard::KEYBOARD_UNSET,
            Configuration_Keyboard::KEYBOARD_NOKEYS,
            Configuration_Keyboard::KEYBOARD_QWERTY,
            Configuration_Keyboard::KEYBOARD_TWELVEKEY,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_Keyboard {
}

impl ::std::default::Default for Configuration_Keyboard {
    fn default() -> Self {
        Configuration_Keyboard::KEYBOARD_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_Keyboard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_NavHidden {
    NAV_HIDDEN_UNSET = 0,
    NAV_HIDDEN_NAVEXPOSED = 1,
    NAV_HIDDEN_NAVHIDDEN = 2,
}

impl ::protobuf::ProtobufEnum for Configuration_NavHidden {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_NavHidden> {
        match value {
            0 => ::std::option::Option::Some(Configuration_NavHidden::NAV_HIDDEN_UNSET),
            1 => ::std::option::Option::Some(Configuration_NavHidden::NAV_HIDDEN_NAVEXPOSED),
            2 => ::std::option::Option::Some(Configuration_NavHidden::NAV_HIDDEN_NAVHIDDEN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_NavHidden] = &[
            Configuration_NavHidden::NAV_HIDDEN_UNSET,
            Configuration_NavHidden::NAV_HIDDEN_NAVEXPOSED,
            Configuration_NavHidden::NAV_HIDDEN_NAVHIDDEN,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_NavHidden {
}

impl ::std::default::Default for Configuration_NavHidden {
    fn default() -> Self {
        Configuration_NavHidden::NAV_HIDDEN_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_NavHidden {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Configuration_Navigation {
    NAVIGATION_UNSET = 0,
    NAVIGATION_NONAV = 1,
    NAVIGATION_DPAD = 2,
    NAVIGATION_TRACKBALL = 3,
    NAVIGATION_WHEEL = 4,
}

impl ::protobuf::ProtobufEnum for Configuration_Navigation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Configuration_Navigation> {
        match value {
            0 => ::std::option::Option::Some(Configuration_Navigation::NAVIGATION_UNSET),
            1 => ::std::option::Option::Some(Configuration_Navigation::NAVIGATION_NONAV),
            2 => ::std::option::Option::Some(Configuration_Navigation::NAVIGATION_DPAD),
            3 => ::std::option::Option::Some(Configuration_Navigation::NAVIGATION_TRACKBALL),
            4 => ::std::option::Option::Some(Configuration_Navigation::NAVIGATION_WHEEL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Configuration_Navigation] = &[
            Configuration_Navigation::NAVIGATION_UNSET,
            Configuration_Navigation::NAVIGATION_NONAV,
            Configuration_Navigation::NAVIGATION_DPAD,
            Configuration_Navigation::NAVIGATION_TRACKBALL,
            Configuration_Navigation::NAVIGATION_WHEEL,
        ];
        values
    }
}

impl ::std::marker::Copy for Configuration_Navigation {
}

impl ::std::default::Default for Configuration_Navigation {
    fn default() -> Self {
        Configuration_Navigation::NAVIGATION_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration_Navigation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
