// This file is generated by rust-protobuf 2.16.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `Resources.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_16_2;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StringPool {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StringPool {
    fn default() -> &'a StringPool {
        <StringPool as ::protobuf::Message>::default_instance()
    }
}

impl StringPool {
    pub fn new() -> StringPool {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StringPool {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StringPool {
        StringPool::new()
    }

    fn default_instance() -> &'static StringPool {
        static instance: ::protobuf::rt::LazyV2<StringPool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StringPool::new)
    }
}

impl ::protobuf::Clear for StringPool {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StringPool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourcePosition {
    // message fields
    pub line_number: u32,
    pub column_number: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SourcePosition {
    fn default() -> &'a SourcePosition {
        <SourcePosition as ::protobuf::Message>::default_instance()
    }
}

impl SourcePosition {
    pub fn new() -> SourcePosition {
        ::std::default::Default::default()
    }

    // uint32 line_number = 1;


    pub fn get_line_number(&self) -> u32 {
        self.line_number
    }
    pub fn clear_line_number(&mut self) {
        self.line_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_number(&mut self, v: u32) {
        self.line_number = v;
    }

    // uint32 column_number = 2;


    pub fn get_column_number(&self) -> u32 {
        self.column_number
    }
    pub fn clear_column_number(&mut self) {
        self.column_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_column_number(&mut self, v: u32) {
        self.column_number = v;
    }
}

impl ::protobuf::Message for SourcePosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.line_number = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.column_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.line_number != 0 {
            my_size += ::protobuf::rt::value_size(1, self.line_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.column_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.column_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.line_number != 0 {
            os.write_uint32(1, self.line_number)?;
        }
        if self.column_number != 0 {
            os.write_uint32(2, self.column_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourcePosition {
        SourcePosition::new()
    }

    fn default_instance() -> &'static SourcePosition {
        static instance: ::protobuf::rt::LazyV2<SourcePosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SourcePosition::new)
    }
}

impl ::protobuf::Clear for SourcePosition {
    fn clear(&mut self) {
        self.line_number = 0;
        self.column_number = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SourcePosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Source {
    // message fields
    pub path_idx: u32,
    pub position: ::protobuf::SingularPtrField<SourcePosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Source {
    fn default() -> &'a Source {
        <Source as ::protobuf::Message>::default_instance()
    }
}

impl Source {
    pub fn new() -> Source {
        ::std::default::Default::default()
    }

    // uint32 path_idx = 1;


    pub fn get_path_idx(&self) -> u32 {
        self.path_idx
    }
    pub fn clear_path_idx(&mut self) {
        self.path_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_path_idx(&mut self, v: u32) {
        self.path_idx = v;
    }

    // .aapt.pb.SourcePosition position = 2;


    pub fn get_position(&self) -> &SourcePosition {
        self.position.as_ref().unwrap_or_else(|| <SourcePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: SourcePosition) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut SourcePosition {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> SourcePosition {
        self.position.take().unwrap_or_else(|| SourcePosition::new())
    }
}

impl ::protobuf::Message for Source {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.path_idx = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.path_idx != 0 {
            my_size += ::protobuf::rt::value_size(1, self.path_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.path_idx != 0 {
            os.write_uint32(1, self.path_idx)?;
        }
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Source {
        Source::new()
    }

    fn default_instance() -> &'static Source {
        static instance: ::protobuf::rt::LazyV2<Source> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Source::new)
    }
}

impl ::protobuf::Clear for Source {
    fn clear(&mut self) {
        self.path_idx = 0;
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Source {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ToolFingerprint {
    // message fields
    pub tool: ::std::string::String,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ToolFingerprint {
    fn default() -> &'a ToolFingerprint {
        <ToolFingerprint as ::protobuf::Message>::default_instance()
    }
}

impl ToolFingerprint {
    pub fn new() -> ToolFingerprint {
        ::std::default::Default::default()
    }

    // string tool = 1;


    pub fn get_tool(&self) -> &str {
        &self.tool
    }
    pub fn clear_tool(&mut self) {
        self.tool.clear();
    }

    // Param is passed by value, moved
    pub fn set_tool(&mut self, v: ::std::string::String) {
        self.tool = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tool(&mut self) -> &mut ::std::string::String {
        &mut self.tool
    }

    // Take field
    pub fn take_tool(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tool, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ToolFingerprint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tool)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tool.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tool);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tool.is_empty() {
            os.write_string(1, &self.tool)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ToolFingerprint {
        ToolFingerprint::new()
    }

    fn default_instance() -> &'static ToolFingerprint {
        static instance: ::protobuf::rt::LazyV2<ToolFingerprint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ToolFingerprint::new)
    }
}

impl ::protobuf::Clear for ToolFingerprint {
    fn clear(&mut self) {
        self.tool.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ToolFingerprint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResourceTable {
    // message fields
    pub source_pool: ::protobuf::SingularPtrField<StringPool>,
    pub package: ::protobuf::RepeatedField<Package>,
    pub overlayable: ::protobuf::RepeatedField<Overlayable>,
    pub tool_fingerprint: ::protobuf::RepeatedField<ToolFingerprint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceTable {
    fn default() -> &'a ResourceTable {
        <ResourceTable as ::protobuf::Message>::default_instance()
    }
}

impl ResourceTable {
    pub fn new() -> ResourceTable {
        ::std::default::Default::default()
    }

    // .aapt.pb.StringPool source_pool = 1;


    pub fn get_source_pool(&self) -> &StringPool {
        self.source_pool.as_ref().unwrap_or_else(|| <StringPool as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source_pool(&mut self) {
        self.source_pool.clear();
    }

    pub fn has_source_pool(&self) -> bool {
        self.source_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_pool(&mut self, v: StringPool) {
        self.source_pool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_pool(&mut self) -> &mut StringPool {
        if self.source_pool.is_none() {
            self.source_pool.set_default();
        }
        self.source_pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_pool(&mut self) -> StringPool {
        self.source_pool.take().unwrap_or_else(|| StringPool::new())
    }

    // repeated .aapt.pb.Package package = 2;


    pub fn get_package(&self) -> &[Package] {
        &self.package
    }
    pub fn clear_package(&mut self) {
        self.package.clear();
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::protobuf::RepeatedField<Package>) {
        self.package = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package(&mut self) -> &mut ::protobuf::RepeatedField<Package> {
        &mut self.package
    }

    // Take field
    pub fn take_package(&mut self) -> ::protobuf::RepeatedField<Package> {
        ::std::mem::replace(&mut self.package, ::protobuf::RepeatedField::new())
    }

    // repeated .aapt.pb.Overlayable overlayable = 3;


    pub fn get_overlayable(&self) -> &[Overlayable] {
        &self.overlayable
    }
    pub fn clear_overlayable(&mut self) {
        self.overlayable.clear();
    }

    // Param is passed by value, moved
    pub fn set_overlayable(&mut self, v: ::protobuf::RepeatedField<Overlayable>) {
        self.overlayable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_overlayable(&mut self) -> &mut ::protobuf::RepeatedField<Overlayable> {
        &mut self.overlayable
    }

    // Take field
    pub fn take_overlayable(&mut self) -> ::protobuf::RepeatedField<Overlayable> {
        ::std::mem::replace(&mut self.overlayable, ::protobuf::RepeatedField::new())
    }

    // repeated .aapt.pb.ToolFingerprint tool_fingerprint = 4;


    pub fn get_tool_fingerprint(&self) -> &[ToolFingerprint] {
        &self.tool_fingerprint
    }
    pub fn clear_tool_fingerprint(&mut self) {
        self.tool_fingerprint.clear();
    }

    // Param is passed by value, moved
    pub fn set_tool_fingerprint(&mut self, v: ::protobuf::RepeatedField<ToolFingerprint>) {
        self.tool_fingerprint = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tool_fingerprint(&mut self) -> &mut ::protobuf::RepeatedField<ToolFingerprint> {
        &mut self.tool_fingerprint
    }

    // Take field
    pub fn take_tool_fingerprint(&mut self) -> ::protobuf::RepeatedField<ToolFingerprint> {
        ::std::mem::replace(&mut self.tool_fingerprint, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResourceTable {
    fn is_initialized(&self) -> bool {
        for v in &self.source_pool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.package {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overlayable {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tool_fingerprint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_pool)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.overlayable)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tool_fingerprint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source_pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.package {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.overlayable {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tool_fingerprint {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source_pool.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.package {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.overlayable {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tool_fingerprint {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceTable {
        ResourceTable::new()
    }

    fn default_instance() -> &'static ResourceTable {
        static instance: ::protobuf::rt::LazyV2<ResourceTable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceTable::new)
    }
}

impl ::protobuf::Clear for ResourceTable {
    fn clear(&mut self) {
        self.source_pool.clear();
        self.package.clear();
        self.overlayable.clear();
        self.tool_fingerprint.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceTable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PackageId {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PackageId {
    fn default() -> &'a PackageId {
        <PackageId as ::protobuf::Message>::default_instance()
    }
}

impl PackageId {
    pub fn new() -> PackageId {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for PackageId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PackageId {
        PackageId::new()
    }

    fn default_instance() -> &'static PackageId {
        static instance: ::protobuf::rt::LazyV2<PackageId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PackageId::new)
    }
}

impl ::protobuf::Clear for PackageId {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PackageId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Package {
    // message fields
    pub package_id: ::protobuf::SingularPtrField<PackageId>,
    pub package_name: ::std::string::String,
    pub field_type: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Package {
    fn default() -> &'a Package {
        <Package as ::protobuf::Message>::default_instance()
    }
}

impl Package {
    pub fn new() -> Package {
        ::std::default::Default::default()
    }

    // .aapt.pb.PackageId package_id = 1;


    pub fn get_package_id(&self) -> &PackageId {
        self.package_id.as_ref().unwrap_or_else(|| <PackageId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_package_id(&mut self) {
        self.package_id.clear();
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: PackageId) {
        self.package_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package_id(&mut self) -> &mut PackageId {
        if self.package_id.is_none() {
            self.package_id.set_default();
        }
        self.package_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_package_id(&mut self) -> PackageId {
        self.package_id.take().unwrap_or_else(|| PackageId::new())
    }

    // string package_name = 2;


    pub fn get_package_name(&self) -> &str {
        &self.package_name
    }
    pub fn clear_package_name(&mut self) {
        self.package_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_name(&mut self, v: ::std::string::String) {
        self.package_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package_name(&mut self) -> &mut ::std::string::String {
        &mut self.package_name
    }

    // Take field
    pub fn take_package_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.package_name, ::std::string::String::new())
    }

    // repeated .aapt.pb.Type type = 3;


    pub fn get_field_type(&self) -> &[Type] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.field_type, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Package {
    fn is_initialized(&self) -> bool {
        for v in &self.package_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.package_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.package_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.package_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.package_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.package_name);
        }
        for value in &self.field_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.package_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.package_name.is_empty() {
            os.write_string(2, &self.package_name)?;
        }
        for v in &self.field_type {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Package {
        Package::new()
    }

    fn default_instance() -> &'static Package {
        static instance: ::protobuf::rt::LazyV2<Package> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Package::new)
    }
}

impl ::protobuf::Clear for Package {
    fn clear(&mut self) {
        self.package_id.clear();
        self.package_name.clear();
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Package {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeId {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeId {
    fn default() -> &'a TypeId {
        <TypeId as ::protobuf::Message>::default_instance()
    }
}

impl TypeId {
    pub fn new() -> TypeId {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for TypeId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeId {
        TypeId::new()
    }

    fn default_instance() -> &'static TypeId {
        static instance: ::protobuf::rt::LazyV2<TypeId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeId::new)
    }
}

impl ::protobuf::Clear for TypeId {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Type {
    // message fields
    pub type_id: ::protobuf::SingularPtrField<TypeId>,
    pub name: ::std::string::String,
    pub entry: ::protobuf::RepeatedField<Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // .aapt.pb.TypeId type_id = 1;


    pub fn get_type_id(&self) -> &TypeId {
        self.type_id.as_ref().unwrap_or_else(|| <TypeId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_type_id(&mut self) {
        self.type_id.clear();
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: TypeId) {
        self.type_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_id(&mut self) -> &mut TypeId {
        if self.type_id.is_none() {
            self.type_id.set_default();
        }
        self.type_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_id(&mut self) -> TypeId {
        self.type_id.take().unwrap_or_else(|| TypeId::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .aapt.pb.Entry entry = 3;


    pub fn get_entry(&self) -> &[Entry] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<Entry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<Entry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<Entry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        for v in &self.type_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.type_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.type_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.entry {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn default_instance() -> &'static Type {
        static instance: ::protobuf::rt::LazyV2<Type> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type::new)
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.type_id.clear();
        self.name.clear();
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Visibility {
    // message fields
    pub level: Visibility_Level,
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Visibility {
    fn default() -> &'a Visibility {
        <Visibility as ::protobuf::Message>::default_instance()
    }
}

impl Visibility {
    pub fn new() -> Visibility {
        ::std::default::Default::default()
    }

    // .aapt.pb.Visibility.Level level = 1;


    pub fn get_level(&self) -> Visibility_Level {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = Visibility_Level::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: Visibility_Level) {
        self.level = v;
    }

    // .aapt.pb.Source source = 2;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 3;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Visibility {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != Visibility_Level::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.comment);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != Visibility_Level::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(3, &self.comment)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Visibility {
        Visibility::new()
    }

    fn default_instance() -> &'static Visibility {
        static instance: ::protobuf::rt::LazyV2<Visibility> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Visibility::new)
    }
}

impl ::protobuf::Clear for Visibility {
    fn clear(&mut self) {
        self.level = Visibility_Level::UNKNOWN;
        self.source.clear();
        self.comment.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Visibility {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Visibility_Level {
    UNKNOWN = 0,
    PRIVATE = 1,
    PUBLIC = 2,
}

impl ::protobuf::ProtobufEnum for Visibility_Level {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Visibility_Level> {
        match value {
            0 => ::std::option::Option::Some(Visibility_Level::UNKNOWN),
            1 => ::std::option::Option::Some(Visibility_Level::PRIVATE),
            2 => ::std::option::Option::Some(Visibility_Level::PUBLIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Visibility_Level] = &[
            Visibility_Level::UNKNOWN,
            Visibility_Level::PRIVATE,
            Visibility_Level::PUBLIC,
        ];
        values
    }
}

impl ::std::marker::Copy for Visibility_Level {
}

impl ::std::default::Default for Visibility_Level {
    fn default() -> Self {
        Visibility_Level::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Visibility_Level {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllowNew {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowNew {
    fn default() -> &'a AllowNew {
        <AllowNew as ::protobuf::Message>::default_instance()
    }
}

impl AllowNew {
    pub fn new() -> AllowNew {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AllowNew {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowNew {
        AllowNew::new()
    }

    fn default_instance() -> &'static AllowNew {
        static instance: ::protobuf::rt::LazyV2<AllowNew> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllowNew::new)
    }
}

impl ::protobuf::Clear for AllowNew {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowNew {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Overlayable {
    // message fields
    pub name: ::std::string::String,
    pub source: ::protobuf::SingularPtrField<Source>,
    pub actor: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Overlayable {
    fn default() -> &'a Overlayable {
        <Overlayable as ::protobuf::Message>::default_instance()
    }
}

impl Overlayable {
    pub fn new() -> Overlayable {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .aapt.pb.Source source = 2;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string actor = 3;


    pub fn get_actor(&self) -> &str {
        &self.actor
    }
    pub fn clear_actor(&mut self) {
        self.actor.clear();
    }

    // Param is passed by value, moved
    pub fn set_actor(&mut self, v: ::std::string::String) {
        self.actor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actor(&mut self) -> &mut ::std::string::String {
        &mut self.actor
    }

    // Take field
    pub fn take_actor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.actor, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Overlayable {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.actor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.actor.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.actor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.actor.is_empty() {
            os.write_string(3, &self.actor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Overlayable {
        Overlayable::new()
    }

    fn default_instance() -> &'static Overlayable {
        static instance: ::protobuf::rt::LazyV2<Overlayable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Overlayable::new)
    }
}

impl ::protobuf::Clear for Overlayable {
    fn clear(&mut self) {
        self.name.clear();
        self.source.clear();
        self.actor.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Overlayable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct OverlayableItem {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub policy: ::std::vec::Vec<OverlayableItem_Policy>,
    pub overlayable_idx: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OverlayableItem {
    fn default() -> &'a OverlayableItem {
        <OverlayableItem as ::protobuf::Message>::default_instance()
    }
}

impl OverlayableItem {
    pub fn new() -> OverlayableItem {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // repeated .aapt.pb.OverlayableItem.Policy policy = 3;


    pub fn get_policy(&self) -> &[OverlayableItem_Policy] {
        &self.policy
    }
    pub fn clear_policy(&mut self) {
        self.policy.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy(&mut self, v: ::std::vec::Vec<OverlayableItem_Policy>) {
        self.policy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policy(&mut self) -> &mut ::std::vec::Vec<OverlayableItem_Policy> {
        &mut self.policy
    }

    // Take field
    pub fn take_policy(&mut self) -> ::std::vec::Vec<OverlayableItem_Policy> {
        ::std::mem::replace(&mut self.policy, ::std::vec::Vec::new())
    }

    // uint32 overlayable_idx = 4;


    pub fn get_overlayable_idx(&self) -> u32 {
        self.overlayable_idx
    }
    pub fn clear_overlayable_idx(&mut self) {
        self.overlayable_idx = 0;
    }

    // Param is passed by value, moved
    pub fn set_overlayable_idx(&mut self, v: u32) {
        self.overlayable_idx = v;
    }
}

impl ::protobuf::Message for OverlayableItem {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.policy, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.overlayable_idx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        for value in &self.policy {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        if self.overlayable_idx != 0 {
            my_size += ::protobuf::rt::value_size(4, self.overlayable_idx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        for v in &self.policy {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.overlayable_idx != 0 {
            os.write_uint32(4, self.overlayable_idx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OverlayableItem {
        OverlayableItem::new()
    }

    fn default_instance() -> &'static OverlayableItem {
        static instance: ::protobuf::rt::LazyV2<OverlayableItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OverlayableItem::new)
    }
}

impl ::protobuf::Clear for OverlayableItem {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.policy.clear();
        self.overlayable_idx = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for OverlayableItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OverlayableItem_Policy {
    NONE = 0,
    PUBLIC = 1,
    SYSTEM = 2,
    VENDOR = 3,
    PRODUCT = 4,
    SIGNATURE = 5,
    ODM = 6,
    OEM = 7,
}

impl ::protobuf::ProtobufEnum for OverlayableItem_Policy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OverlayableItem_Policy> {
        match value {
            0 => ::std::option::Option::Some(OverlayableItem_Policy::NONE),
            1 => ::std::option::Option::Some(OverlayableItem_Policy::PUBLIC),
            2 => ::std::option::Option::Some(OverlayableItem_Policy::SYSTEM),
            3 => ::std::option::Option::Some(OverlayableItem_Policy::VENDOR),
            4 => ::std::option::Option::Some(OverlayableItem_Policy::PRODUCT),
            5 => ::std::option::Option::Some(OverlayableItem_Policy::SIGNATURE),
            6 => ::std::option::Option::Some(OverlayableItem_Policy::ODM),
            7 => ::std::option::Option::Some(OverlayableItem_Policy::OEM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OverlayableItem_Policy] = &[
            OverlayableItem_Policy::NONE,
            OverlayableItem_Policy::PUBLIC,
            OverlayableItem_Policy::SYSTEM,
            OverlayableItem_Policy::VENDOR,
            OverlayableItem_Policy::PRODUCT,
            OverlayableItem_Policy::SIGNATURE,
            OverlayableItem_Policy::ODM,
            OverlayableItem_Policy::OEM,
        ];
        values
    }
}

impl ::std::marker::Copy for OverlayableItem_Policy {
}

impl ::std::default::Default for OverlayableItem_Policy {
    fn default() -> Self {
        OverlayableItem_Policy::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for OverlayableItem_Policy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EntryId {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntryId {
    fn default() -> &'a EntryId {
        <EntryId as ::protobuf::Message>::default_instance()
    }
}

impl EntryId {
    pub fn new() -> EntryId {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for EntryId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntryId {
        EntryId::new()
    }

    fn default_instance() -> &'static EntryId {
        static instance: ::protobuf::rt::LazyV2<EntryId> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EntryId::new)
    }
}

impl ::protobuf::Clear for EntryId {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EntryId {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Entry {
    // message fields
    pub entry_id: ::protobuf::SingularPtrField<EntryId>,
    pub name: ::std::string::String,
    pub visibility: ::protobuf::SingularPtrField<Visibility>,
    pub allow_new: ::protobuf::SingularPtrField<AllowNew>,
    pub overlayable_item: ::protobuf::SingularPtrField<OverlayableItem>,
    pub config_value: ::protobuf::RepeatedField<ConfigValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Entry {
    fn default() -> &'a Entry {
        <Entry as ::protobuf::Message>::default_instance()
    }
}

impl Entry {
    pub fn new() -> Entry {
        ::std::default::Default::default()
    }

    // .aapt.pb.EntryId entry_id = 1;


    pub fn get_entry_id(&self) -> &EntryId {
        self.entry_id.as_ref().unwrap_or_else(|| <EntryId as ::protobuf::Message>::default_instance())
    }
    pub fn clear_entry_id(&mut self) {
        self.entry_id.clear();
    }

    pub fn has_entry_id(&self) -> bool {
        self.entry_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entry_id(&mut self, v: EntryId) {
        self.entry_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_id(&mut self) -> &mut EntryId {
        if self.entry_id.is_none() {
            self.entry_id.set_default();
        }
        self.entry_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_entry_id(&mut self) -> EntryId {
        self.entry_id.take().unwrap_or_else(|| EntryId::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .aapt.pb.Visibility visibility = 3;


    pub fn get_visibility(&self) -> &Visibility {
        self.visibility.as_ref().unwrap_or_else(|| <Visibility as ::protobuf::Message>::default_instance())
    }
    pub fn clear_visibility(&mut self) {
        self.visibility.clear();
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: Visibility) {
        self.visibility = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_visibility(&mut self) -> &mut Visibility {
        if self.visibility.is_none() {
            self.visibility.set_default();
        }
        self.visibility.as_mut().unwrap()
    }

    // Take field
    pub fn take_visibility(&mut self) -> Visibility {
        self.visibility.take().unwrap_or_else(|| Visibility::new())
    }

    // .aapt.pb.AllowNew allow_new = 4;


    pub fn get_allow_new(&self) -> &AllowNew {
        self.allow_new.as_ref().unwrap_or_else(|| <AllowNew as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allow_new(&mut self) {
        self.allow_new.clear();
    }

    pub fn has_allow_new(&self) -> bool {
        self.allow_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_new(&mut self, v: AllowNew) {
        self.allow_new = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_new(&mut self) -> &mut AllowNew {
        if self.allow_new.is_none() {
            self.allow_new.set_default();
        }
        self.allow_new.as_mut().unwrap()
    }

    // Take field
    pub fn take_allow_new(&mut self) -> AllowNew {
        self.allow_new.take().unwrap_or_else(|| AllowNew::new())
    }

    // .aapt.pb.OverlayableItem overlayable_item = 5;


    pub fn get_overlayable_item(&self) -> &OverlayableItem {
        self.overlayable_item.as_ref().unwrap_or_else(|| <OverlayableItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overlayable_item(&mut self) {
        self.overlayable_item.clear();
    }

    pub fn has_overlayable_item(&self) -> bool {
        self.overlayable_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlayable_item(&mut self, v: OverlayableItem) {
        self.overlayable_item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overlayable_item(&mut self) -> &mut OverlayableItem {
        if self.overlayable_item.is_none() {
            self.overlayable_item.set_default();
        }
        self.overlayable_item.as_mut().unwrap()
    }

    // Take field
    pub fn take_overlayable_item(&mut self) -> OverlayableItem {
        self.overlayable_item.take().unwrap_or_else(|| OverlayableItem::new())
    }

    // repeated .aapt.pb.ConfigValue config_value = 6;


    pub fn get_config_value(&self) -> &[ConfigValue] {
        &self.config_value
    }
    pub fn clear_config_value(&mut self) {
        self.config_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_value(&mut self, v: ::protobuf::RepeatedField<ConfigValue>) {
        self.config_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config_value(&mut self) -> &mut ::protobuf::RepeatedField<ConfigValue> {
        &mut self.config_value
    }

    // Take field
    pub fn take_config_value(&mut self) -> ::protobuf::RepeatedField<ConfigValue> {
        ::std::mem::replace(&mut self.config_value, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.entry_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.visibility {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allow_new {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overlayable_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.entry_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.visibility)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allow_new)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overlayable_item)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.config_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.entry_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.visibility.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.allow_new.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.overlayable_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.config_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.entry_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.visibility.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.allow_new.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.overlayable_item.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.config_value {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entry {
        Entry::new()
    }

    fn default_instance() -> &'static Entry {
        static instance: ::protobuf::rt::LazyV2<Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Entry::new)
    }
}

impl ::protobuf::Clear for Entry {
    fn clear(&mut self) {
        self.entry_id.clear();
        self.name.clear();
        self.visibility.clear();
        self.allow_new.clear();
        self.overlayable_item.clear();
        self.config_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigValue {
    // message fields
    pub config: ::protobuf::SingularPtrField<super::Configuration::Configuration>,
    pub value: ::protobuf::SingularPtrField<Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigValue {
    fn default() -> &'a ConfigValue {
        <ConfigValue as ::protobuf::Message>::default_instance()
    }
}

impl ConfigValue {
    pub fn new() -> ConfigValue {
        ::std::default::Default::default()
    }

    // .aapt.pb.Configuration config = 1;


    pub fn get_config(&self) -> &super::Configuration::Configuration {
        self.config.as_ref().unwrap_or_else(|| <super::Configuration::Configuration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: super::Configuration::Configuration) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut super::Configuration::Configuration {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> super::Configuration::Configuration {
        self.config.take().unwrap_or_else(|| super::Configuration::Configuration::new())
    }

    // .aapt.pb.Value value = 2;


    pub fn get_value(&self) -> &Value {
        self.value.as_ref().unwrap_or_else(|| <Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Value {
        self.value.take().unwrap_or_else(|| Value::new())
    }
}

impl ::protobuf::Message for ConfigValue {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigValue {
        ConfigValue::new()
    }

    fn default_instance() -> &'static ConfigValue {
        static instance: ::protobuf::rt::LazyV2<ConfigValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigValue::new)
    }
}

impl ::protobuf::Clear for ConfigValue {
    fn clear(&mut self) {
        self.config.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Value {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub weak: bool,
    // message oneof groups
    pub value: ::std::option::Option<Value_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Value {
    fn default() -> &'a Value {
        <Value as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Value_oneof_value {
    item(Item),
    compound_value(CompoundValue),
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // bool weak = 3;


    pub fn get_weak(&self) -> bool {
        self.weak
    }
    pub fn clear_weak(&mut self) {
        self.weak = false;
    }

    // Param is passed by value, moved
    pub fn set_weak(&mut self, v: bool) {
        self.weak = v;
    }

    // .aapt.pb.Item item = 4;


    pub fn get_item(&self) -> &Item {
        match self.value {
            ::std::option::Option::Some(Value_oneof_value::item(ref v)) => v,
            _ => <Item as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_item(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Value_oneof_value::item(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.value = ::std::option::Option::Some(Value_oneof_value::item(v))
    }

    // Mutable pointer to the field.
    pub fn mut_item(&mut self) -> &mut Item {
        if let ::std::option::Option::Some(Value_oneof_value::item(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Value_oneof_value::item(Item::new()));
        }
        match self.value {
            ::std::option::Option::Some(Value_oneof_value::item(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        if self.has_item() {
            match self.value.take() {
                ::std::option::Option::Some(Value_oneof_value::item(v)) => v,
                _ => panic!(),
            }
        } else {
            Item::new()
        }
    }

    // .aapt.pb.CompoundValue compound_value = 5;


    pub fn get_compound_value(&self) -> &CompoundValue {
        match self.value {
            ::std::option::Option::Some(Value_oneof_value::compound_value(ref v)) => v,
            _ => <CompoundValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_compound_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_compound_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Value_oneof_value::compound_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_compound_value(&mut self, v: CompoundValue) {
        self.value = ::std::option::Option::Some(Value_oneof_value::compound_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_compound_value(&mut self) -> &mut CompoundValue {
        if let ::std::option::Option::Some(Value_oneof_value::compound_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Value_oneof_value::compound_value(CompoundValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(Value_oneof_value::compound_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_compound_value(&mut self) -> CompoundValue {
        if self.has_compound_value() {
            match self.value.take() {
                ::std::option::Option::Some(Value_oneof_value::compound_value(v)) => v,
                _ => panic!(),
            }
        } else {
            CompoundValue::new()
        }
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Value_oneof_value::item(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Value_oneof_value::compound_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.weak = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Value_oneof_value::item(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Value_oneof_value::compound_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        if self.weak != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Value_oneof_value::item(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Value_oneof_value::compound_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        if self.weak != false {
            os.write_bool(3, self.weak)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Value_oneof_value::item(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Value_oneof_value::compound_value(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Value {
        Value::new()
    }

    fn default_instance() -> &'static Value {
        static instance: ::protobuf::rt::LazyV2<Value> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Value::new)
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.weak = false;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Value {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Item {
    // message oneof groups
    pub value: ::std::option::Option<Item_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Item {
    fn default() -> &'a Item {
        <Item as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Item_oneof_value {
    field_ref(Reference),
    str(String),
    raw_str(RawString),
    styled_str(StyledString),
    file(FileReference),
    id(Id),
    prim(Primitive),
}

impl Item {
    pub fn new() -> Item {
        ::std::default::Default::default()
    }

    // .aapt.pb.Reference ref = 1;


    pub fn get_field_ref(&self) -> &Reference {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::field_ref(ref v)) => v,
            _ => <Reference as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_field_ref(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_field_ref(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::field_ref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_ref(&mut self, v: Reference) {
        self.value = ::std::option::Option::Some(Item_oneof_value::field_ref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_ref(&mut self) -> &mut Reference {
        if let ::std::option::Option::Some(Item_oneof_value::field_ref(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::field_ref(Reference::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::field_ref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_ref(&mut self) -> Reference {
        if self.has_field_ref() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::field_ref(v)) => v,
                _ => panic!(),
            }
        } else {
            Reference::new()
        }
    }

    // .aapt.pb.String str = 2;


    pub fn get_str(&self) -> &String {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::str(ref v)) => v,
            _ => <String as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_str(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_str(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_str(&mut self, v: String) {
        self.value = ::std::option::Option::Some(Item_oneof_value::str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_str(&mut self) -> &mut String {
        if let ::std::option::Option::Some(Item_oneof_value::str(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::str(String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_str(&mut self) -> String {
        if self.has_str() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::str(v)) => v,
                _ => panic!(),
            }
        } else {
            String::new()
        }
    }

    // .aapt.pb.RawString raw_str = 3;


    pub fn get_raw_str(&self) -> &RawString {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::raw_str(ref v)) => v,
            _ => <RawString as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_raw_str(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_raw_str(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::raw_str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_raw_str(&mut self, v: RawString) {
        self.value = ::std::option::Option::Some(Item_oneof_value::raw_str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_raw_str(&mut self) -> &mut RawString {
        if let ::std::option::Option::Some(Item_oneof_value::raw_str(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::raw_str(RawString::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::raw_str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_raw_str(&mut self) -> RawString {
        if self.has_raw_str() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::raw_str(v)) => v,
                _ => panic!(),
            }
        } else {
            RawString::new()
        }
    }

    // .aapt.pb.StyledString styled_str = 4;


    pub fn get_styled_str(&self) -> &StyledString {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::styled_str(ref v)) => v,
            _ => <StyledString as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_styled_str(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_styled_str(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::styled_str(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_styled_str(&mut self, v: StyledString) {
        self.value = ::std::option::Option::Some(Item_oneof_value::styled_str(v))
    }

    // Mutable pointer to the field.
    pub fn mut_styled_str(&mut self) -> &mut StyledString {
        if let ::std::option::Option::Some(Item_oneof_value::styled_str(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::styled_str(StyledString::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::styled_str(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_styled_str(&mut self) -> StyledString {
        if self.has_styled_str() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::styled_str(v)) => v,
                _ => panic!(),
            }
        } else {
            StyledString::new()
        }
    }

    // .aapt.pb.FileReference file = 5;


    pub fn get_file(&self) -> &FileReference {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::file(ref v)) => v,
            _ => <FileReference as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_file(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::file(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: FileReference) {
        self.value = ::std::option::Option::Some(Item_oneof_value::file(v))
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut FileReference {
        if let ::std::option::Option::Some(Item_oneof_value::file(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::file(FileReference::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::file(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_file(&mut self) -> FileReference {
        if self.has_file() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::file(v)) => v,
                _ => panic!(),
            }
        } else {
            FileReference::new()
        }
    }

    // .aapt.pb.Id id = 6;


    pub fn get_id(&self) -> &Id {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::id(ref v)) => v,
            _ => <Id as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_id(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: Id) {
        self.value = ::std::option::Option::Some(Item_oneof_value::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut Id {
        if let ::std::option::Option::Some(Item_oneof_value::id(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::id(Id::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> Id {
        if self.has_id() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::id(v)) => v,
                _ => panic!(),
            }
        } else {
            Id::new()
        }
    }

    // .aapt.pb.Primitive prim = 7;


    pub fn get_prim(&self) -> &Primitive {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::prim(ref v)) => v,
            _ => <Primitive as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_prim(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_prim(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::prim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prim(&mut self, v: Primitive) {
        self.value = ::std::option::Option::Some(Item_oneof_value::prim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prim(&mut self) -> &mut Primitive {
        if let ::std::option::Option::Some(Item_oneof_value::prim(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Item_oneof_value::prim(Primitive::new()));
        }
        match self.value {
            ::std::option::Option::Some(Item_oneof_value::prim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prim(&mut self) -> Primitive {
        if self.has_prim() {
            match self.value.take() {
                ::std::option::Option::Some(Item_oneof_value::prim(v)) => v,
                _ => panic!(),
            }
        } else {
            Primitive::new()
        }
    }
}

impl ::protobuf::Message for Item {
    fn is_initialized(&self) -> bool {
        if let Some(Item_oneof_value::field_ref(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Item_oneof_value::str(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Item_oneof_value::raw_str(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Item_oneof_value::styled_str(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Item_oneof_value::file(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Item_oneof_value::id(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Item_oneof_value::prim(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::field_ref(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::str(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::raw_str(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::styled_str(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::file(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::id(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Item_oneof_value::prim(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Item_oneof_value::field_ref(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Item_oneof_value::str(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Item_oneof_value::raw_str(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Item_oneof_value::styled_str(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Item_oneof_value::file(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Item_oneof_value::id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Item_oneof_value::prim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Item_oneof_value::field_ref(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Item_oneof_value::str(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Item_oneof_value::raw_str(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Item_oneof_value::styled_str(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Item_oneof_value::file(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Item_oneof_value::id(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Item_oneof_value::prim(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Item {
        Item::new()
    }

    fn default_instance() -> &'static Item {
        static instance: ::protobuf::rt::LazyV2<Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Item::new)
    }
}

impl ::protobuf::Clear for Item {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CompoundValue {
    // message oneof groups
    pub value: ::std::option::Option<CompoundValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompoundValue {
    fn default() -> &'a CompoundValue {
        <CompoundValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CompoundValue_oneof_value {
    attr(Attribute),
    style(Style),
    styleable(Styleable),
    array(Array),
    plural(Plural),
}

impl CompoundValue {
    pub fn new() -> CompoundValue {
        ::std::default::Default::default()
    }

    // .aapt.pb.Attribute attr = 1;


    pub fn get_attr(&self) -> &Attribute {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::attr(ref v)) => v,
            _ => <Attribute as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_attr(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_attr(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::attr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attr(&mut self, v: Attribute) {
        self.value = ::std::option::Option::Some(CompoundValue_oneof_value::attr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attr(&mut self) -> &mut Attribute {
        if let ::std::option::Option::Some(CompoundValue_oneof_value::attr(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(CompoundValue_oneof_value::attr(Attribute::new()));
        }
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::attr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attr(&mut self) -> Attribute {
        if self.has_attr() {
            match self.value.take() {
                ::std::option::Option::Some(CompoundValue_oneof_value::attr(v)) => v,
                _ => panic!(),
            }
        } else {
            Attribute::new()
        }
    }

    // .aapt.pb.Style style = 2;


    pub fn get_style(&self) -> &Style {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::style(ref v)) => v,
            _ => <Style as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_style(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::style(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: Style) {
        self.value = ::std::option::Option::Some(CompoundValue_oneof_value::style(v))
    }

    // Mutable pointer to the field.
    pub fn mut_style(&mut self) -> &mut Style {
        if let ::std::option::Option::Some(CompoundValue_oneof_value::style(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(CompoundValue_oneof_value::style(Style::new()));
        }
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::style(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_style(&mut self) -> Style {
        if self.has_style() {
            match self.value.take() {
                ::std::option::Option::Some(CompoundValue_oneof_value::style(v)) => v,
                _ => panic!(),
            }
        } else {
            Style::new()
        }
    }

    // .aapt.pb.Styleable styleable = 3;


    pub fn get_styleable(&self) -> &Styleable {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::styleable(ref v)) => v,
            _ => <Styleable as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_styleable(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_styleable(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::styleable(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_styleable(&mut self, v: Styleable) {
        self.value = ::std::option::Option::Some(CompoundValue_oneof_value::styleable(v))
    }

    // Mutable pointer to the field.
    pub fn mut_styleable(&mut self) -> &mut Styleable {
        if let ::std::option::Option::Some(CompoundValue_oneof_value::styleable(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(CompoundValue_oneof_value::styleable(Styleable::new()));
        }
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::styleable(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_styleable(&mut self) -> Styleable {
        if self.has_styleable() {
            match self.value.take() {
                ::std::option::Option::Some(CompoundValue_oneof_value::styleable(v)) => v,
                _ => panic!(),
            }
        } else {
            Styleable::new()
        }
    }

    // .aapt.pb.Array array = 4;


    pub fn get_array(&self) -> &Array {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::array(ref v)) => v,
            _ => <Array as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_array(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_array(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::array(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_array(&mut self, v: Array) {
        self.value = ::std::option::Option::Some(CompoundValue_oneof_value::array(v))
    }

    // Mutable pointer to the field.
    pub fn mut_array(&mut self) -> &mut Array {
        if let ::std::option::Option::Some(CompoundValue_oneof_value::array(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(CompoundValue_oneof_value::array(Array::new()));
        }
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::array(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_array(&mut self) -> Array {
        if self.has_array() {
            match self.value.take() {
                ::std::option::Option::Some(CompoundValue_oneof_value::array(v)) => v,
                _ => panic!(),
            }
        } else {
            Array::new()
        }
    }

    // .aapt.pb.Plural plural = 5;


    pub fn get_plural(&self) -> &Plural {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::plural(ref v)) => v,
            _ => <Plural as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_plural(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_plural(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::plural(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plural(&mut self, v: Plural) {
        self.value = ::std::option::Option::Some(CompoundValue_oneof_value::plural(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plural(&mut self) -> &mut Plural {
        if let ::std::option::Option::Some(CompoundValue_oneof_value::plural(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(CompoundValue_oneof_value::plural(Plural::new()));
        }
        match self.value {
            ::std::option::Option::Some(CompoundValue_oneof_value::plural(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plural(&mut self) -> Plural {
        if self.has_plural() {
            match self.value.take() {
                ::std::option::Option::Some(CompoundValue_oneof_value::plural(v)) => v,
                _ => panic!(),
            }
        } else {
            Plural::new()
        }
    }
}

impl ::protobuf::Message for CompoundValue {
    fn is_initialized(&self) -> bool {
        if let Some(CompoundValue_oneof_value::attr(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompoundValue_oneof_value::style(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompoundValue_oneof_value::styleable(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompoundValue_oneof_value::array(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CompoundValue_oneof_value::plural(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CompoundValue_oneof_value::attr(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CompoundValue_oneof_value::style(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CompoundValue_oneof_value::styleable(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CompoundValue_oneof_value::array(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CompoundValue_oneof_value::plural(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &CompoundValue_oneof_value::attr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompoundValue_oneof_value::style(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompoundValue_oneof_value::styleable(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompoundValue_oneof_value::array(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CompoundValue_oneof_value::plural(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &CompoundValue_oneof_value::attr(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompoundValue_oneof_value::style(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompoundValue_oneof_value::styleable(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompoundValue_oneof_value::array(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CompoundValue_oneof_value::plural(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompoundValue {
        CompoundValue::new()
    }

    fn default_instance() -> &'static CompoundValue {
        static instance: ::protobuf::rt::LazyV2<CompoundValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompoundValue::new)
    }
}

impl ::protobuf::Clear for CompoundValue {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CompoundValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Reference {
    // message fields
    pub field_type: Reference_Type,
    pub id: u32,
    pub name: ::std::string::String,
    pub private: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reference {
    fn default() -> &'a Reference {
        <Reference as ::protobuf::Message>::default_instance()
    }
}

impl Reference {
    pub fn new() -> Reference {
        ::std::default::Default::default()
    }

    // .aapt.pb.Reference.Type type = 1;


    pub fn get_field_type(&self) -> Reference_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Reference_Type::REFERENCE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Reference_Type) {
        self.field_type = v;
    }

    // uint32 id = 2;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool private = 4;


    pub fn get_private(&self) -> bool {
        self.private
    }
    pub fn clear_private(&mut self) {
        self.private = false;
    }

    // Param is passed by value, moved
    pub fn set_private(&mut self, v: bool) {
        self.private = v;
    }
}

impl ::protobuf::Message for Reference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.private = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Reference_Type::REFERENCE {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.private != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Reference_Type::REFERENCE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.id != 0 {
            os.write_uint32(2, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.private != false {
            os.write_bool(4, self.private)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reference {
        Reference::new()
    }

    fn default_instance() -> &'static Reference {
        static instance: ::protobuf::rt::LazyV2<Reference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Reference::new)
    }
}

impl ::protobuf::Clear for Reference {
    fn clear(&mut self) {
        self.field_type = Reference_Type::REFERENCE;
        self.id = 0;
        self.name.clear();
        self.private = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Reference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Reference_Type {
    REFERENCE = 0,
    ATTRIBUTE = 1,
}

impl ::protobuf::ProtobufEnum for Reference_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Reference_Type> {
        match value {
            0 => ::std::option::Option::Some(Reference_Type::REFERENCE),
            1 => ::std::option::Option::Some(Reference_Type::ATTRIBUTE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Reference_Type] = &[
            Reference_Type::REFERENCE,
            Reference_Type::ATTRIBUTE,
        ];
        values
    }
}

impl ::std::marker::Copy for Reference_Type {
}

impl ::std::default::Default for Reference_Type {
    fn default() -> Self {
        Reference_Type::REFERENCE
    }
}

impl ::protobuf::reflect::ProtobufValue for Reference_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Id {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Id {
    fn default() -> &'a Id {
        <Id as ::protobuf::Message>::default_instance()
    }
}

impl Id {
    pub fn new() -> Id {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Id {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Id {
        Id::new()
    }

    fn default_instance() -> &'static Id {
        static instance: ::protobuf::rt::LazyV2<Id> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Id::new)
    }
}

impl ::protobuf::Clear for Id {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Id {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct String {
    // message fields
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a String {
    fn default() -> &'a String {
        <String as ::protobuf::Message>::default_instance()
    }
}

impl String {
    pub fn new() -> String {
        ::std::default::Default::default()
    }

    // string value = 1;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for String {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> String {
        String::new()
    }

    fn default_instance() -> &'static String {
        static instance: ::protobuf::rt::LazyV2<String> = ::protobuf::rt::LazyV2::INIT;
        instance.get(String::new)
    }
}

impl ::protobuf::Clear for String {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for String {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RawString {
    // message fields
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawString {
    fn default() -> &'a RawString {
        <RawString as ::protobuf::Message>::default_instance()
    }
}

impl RawString {
    pub fn new() -> RawString {
        ::std::default::Default::default()
    }

    // string value = 1;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawString {
        RawString::new()
    }

    fn default_instance() -> &'static RawString {
        static instance: ::protobuf::rt::LazyV2<RawString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RawString::new)
    }
}

impl ::protobuf::Clear for RawString {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RawString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StyledString {
    // message fields
    pub value: ::std::string::String,
    pub span: ::protobuf::RepeatedField<StyledString_Span>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StyledString {
    fn default() -> &'a StyledString {
        <StyledString as ::protobuf::Message>::default_instance()
    }
}

impl StyledString {
    pub fn new() -> StyledString {
        ::std::default::Default::default()
    }

    // string value = 1;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // repeated .aapt.pb.StyledString.Span span = 2;


    pub fn get_span(&self) -> &[StyledString_Span] {
        &self.span
    }
    pub fn clear_span(&mut self) {
        self.span.clear();
    }

    // Param is passed by value, moved
    pub fn set_span(&mut self, v: ::protobuf::RepeatedField<StyledString_Span>) {
        self.span = v;
    }

    // Mutable pointer to the field.
    pub fn mut_span(&mut self) -> &mut ::protobuf::RepeatedField<StyledString_Span> {
        &mut self.span
    }

    // Take field
    pub fn take_span(&mut self) -> ::protobuf::RepeatedField<StyledString_Span> {
        ::std::mem::replace(&mut self.span, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StyledString {
    fn is_initialized(&self) -> bool {
        for v in &self.span {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.span)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        for value in &self.span {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        for v in &self.span {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StyledString {
        StyledString::new()
    }

    fn default_instance() -> &'static StyledString {
        static instance: ::protobuf::rt::LazyV2<StyledString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StyledString::new)
    }
}

impl ::protobuf::Clear for StyledString {
    fn clear(&mut self) {
        self.value.clear();
        self.span.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StyledString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StyledString_Span {
    // message fields
    pub tag: ::std::string::String,
    pub first_char: u32,
    pub last_char: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StyledString_Span {
    fn default() -> &'a StyledString_Span {
        <StyledString_Span as ::protobuf::Message>::default_instance()
    }
}

impl StyledString_Span {
    pub fn new() -> StyledString_Span {
        ::std::default::Default::default()
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }

    // uint32 first_char = 2;


    pub fn get_first_char(&self) -> u32 {
        self.first_char
    }
    pub fn clear_first_char(&mut self) {
        self.first_char = 0;
    }

    // Param is passed by value, moved
    pub fn set_first_char(&mut self, v: u32) {
        self.first_char = v;
    }

    // uint32 last_char = 3;


    pub fn get_last_char(&self) -> u32 {
        self.last_char
    }
    pub fn clear_last_char(&mut self) {
        self.last_char = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_char(&mut self, v: u32) {
        self.last_char = v;
    }
}

impl ::protobuf::Message for StyledString_Span {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.first_char = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_char = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if self.first_char != 0 {
            my_size += ::protobuf::rt::value_size(2, self.first_char, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_char != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_char, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if self.first_char != 0 {
            os.write_uint32(2, self.first_char)?;
        }
        if self.last_char != 0 {
            os.write_uint32(3, self.last_char)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StyledString_Span {
        StyledString_Span::new()
    }

    fn default_instance() -> &'static StyledString_Span {
        static instance: ::protobuf::rt::LazyV2<StyledString_Span> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StyledString_Span::new)
    }
}

impl ::protobuf::Clear for StyledString_Span {
    fn clear(&mut self) {
        self.tag.clear();
        self.first_char = 0;
        self.last_char = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StyledString_Span {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileReference {
    // message fields
    pub path: ::std::string::String,
    pub field_type: FileReference_Type,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileReference {
    fn default() -> &'a FileReference {
        <FileReference as ::protobuf::Message>::default_instance()
    }
}

impl FileReference {
    pub fn new() -> FileReference {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .aapt.pb.FileReference.Type type = 2;


    pub fn get_field_type(&self) -> FileReference_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = FileReference_Type::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FileReference_Type) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for FileReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if self.field_type != FileReference_Type::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if self.field_type != FileReference_Type::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileReference {
        FileReference::new()
    }

    fn default_instance() -> &'static FileReference {
        static instance: ::protobuf::rt::LazyV2<FileReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FileReference::new)
    }
}

impl ::protobuf::Clear for FileReference {
    fn clear(&mut self) {
        self.path.clear();
        self.field_type = FileReference_Type::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FileReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FileReference_Type {
    UNKNOWN = 0,
    PNG = 1,
    BINARY_XML = 2,
    PROTO_XML = 3,
}

impl ::protobuf::ProtobufEnum for FileReference_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileReference_Type> {
        match value {
            0 => ::std::option::Option::Some(FileReference_Type::UNKNOWN),
            1 => ::std::option::Option::Some(FileReference_Type::PNG),
            2 => ::std::option::Option::Some(FileReference_Type::BINARY_XML),
            3 => ::std::option::Option::Some(FileReference_Type::PROTO_XML),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FileReference_Type] = &[
            FileReference_Type::UNKNOWN,
            FileReference_Type::PNG,
            FileReference_Type::BINARY_XML,
            FileReference_Type::PROTO_XML,
        ];
        values
    }
}

impl ::std::marker::Copy for FileReference_Type {
}

impl ::std::default::Default for FileReference_Type {
    fn default() -> Self {
        FileReference_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for FileReference_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Primitive {
    // message oneof groups
    pub oneof_value: ::std::option::Option<Primitive_oneof_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Primitive {
    fn default() -> &'a Primitive {
        <Primitive as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Primitive_oneof_oneof_value {
    null_value(Primitive_NullType),
    empty_value(Primitive_EmptyType),
    float_value(f32),
    dimension_value(u32),
    fraction_value(u32),
    int_decimal_value(i32),
    int_hexadecimal_value(u32),
    boolean_value(bool),
    color_argb8_value(u32),
    color_rgb8_value(u32),
    color_argb4_value(u32),
    color_rgb4_value(u32),
    dimension_value_deprecated(f32),
    fraction_value_deprecated(f32),
}

impl Primitive {
    pub fn new() -> Primitive {
        ::std::default::Default::default()
    }

    // .aapt.pb.Primitive.NullType null_value = 1;


    pub fn get_null_value(&self) -> &Primitive_NullType {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(ref v)) => v,
            _ => <Primitive_NullType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_null_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_null_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_null_value(&mut self, v: Primitive_NullType) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_null_value(&mut self) -> &mut Primitive_NullType {
        if let ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(_)) = self.oneof_value {
        } else {
            self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(Primitive_NullType::new()));
        }
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_null_value(&mut self) -> Primitive_NullType {
        if self.has_null_value() {
            match self.oneof_value.take() {
                ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Primitive_NullType::new()
        }
    }

    // .aapt.pb.Primitive.EmptyType empty_value = 2;


    pub fn get_empty_value(&self) -> &Primitive_EmptyType {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(ref v)) => v,
            _ => <Primitive_EmptyType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_empty_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_empty_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_empty_value(&mut self, v: Primitive_EmptyType) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_empty_value(&mut self) -> &mut Primitive_EmptyType {
        if let ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(_)) = self.oneof_value {
        } else {
            self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(Primitive_EmptyType::new()));
        }
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_empty_value(&mut self) -> Primitive_EmptyType {
        if self.has_empty_value() {
            match self.oneof_value.take() {
                ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(v)) => v,
                _ => panic!(),
            }
        } else {
            Primitive_EmptyType::new()
        }
    }

    // float float_value = 3;


    pub fn get_float_value(&self) -> f32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::float_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::float_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::float_value(v))
    }

    // uint32 dimension_value = 13;


    pub fn get_dimension_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_dimension_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_dimension_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dimension_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value(v))
    }

    // uint32 fraction_value = 14;


    pub fn get_fraction_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_fraction_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_fraction_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fraction_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value(v))
    }

    // int32 int_decimal_value = 6;


    pub fn get_int_decimal_value(&self) -> i32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::int_decimal_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_decimal_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_int_decimal_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::int_decimal_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_decimal_value(&mut self, v: i32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::int_decimal_value(v))
    }

    // uint32 int_hexadecimal_value = 7;


    pub fn get_int_hexadecimal_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::int_hexadecimal_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_hexadecimal_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_int_hexadecimal_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::int_hexadecimal_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_hexadecimal_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::int_hexadecimal_value(v))
    }

    // bool boolean_value = 8;


    pub fn get_boolean_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::boolean_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_boolean_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_boolean_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::boolean_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean_value(&mut self, v: bool) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::boolean_value(v))
    }

    // uint32 color_argb8_value = 9;


    pub fn get_color_argb8_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb8_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_color_argb8_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_color_argb8_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb8_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_argb8_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb8_value(v))
    }

    // uint32 color_rgb8_value = 10;


    pub fn get_color_rgb8_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb8_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_color_rgb8_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_color_rgb8_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb8_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_rgb8_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb8_value(v))
    }

    // uint32 color_argb4_value = 11;


    pub fn get_color_argb4_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb4_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_color_argb4_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_color_argb4_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb4_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_argb4_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb4_value(v))
    }

    // uint32 color_rgb4_value = 12;


    pub fn get_color_rgb4_value(&self) -> u32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb4_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_color_rgb4_value(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_color_rgb4_value(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb4_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_color_rgb4_value(&mut self, v: u32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb4_value(v))
    }

    // float dimension_value_deprecated = 4;


    pub fn get_dimension_value_deprecated(&self) -> f32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value_deprecated(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_dimension_value_deprecated(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_dimension_value_deprecated(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value_deprecated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dimension_value_deprecated(&mut self, v: f32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value_deprecated(v))
    }

    // float fraction_value_deprecated = 5;


    pub fn get_fraction_value_deprecated(&self) -> f32 {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value_deprecated(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_fraction_value_deprecated(&mut self) {
        self.oneof_value = ::std::option::Option::None;
    }

    pub fn has_fraction_value_deprecated(&self) -> bool {
        match self.oneof_value {
            ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value_deprecated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fraction_value_deprecated(&mut self, v: f32) {
        self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value_deprecated(v))
    }
}

impl ::protobuf::Message for Primitive {
    fn is_initialized(&self) -> bool {
        if let Some(Primitive_oneof_oneof_value::null_value(ref v)) = self.oneof_value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Primitive_oneof_oneof_value::empty_value(ref v)) = self.oneof_value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::null_value(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::empty_value(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::float_value(is.read_float()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value(is.read_uint32()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value(is.read_uint32()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::int_decimal_value(is.read_int32()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::int_hexadecimal_value(is.read_uint32()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::boolean_value(is.read_bool()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb8_value(is.read_uint32()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb8_value(is.read_uint32()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_argb4_value(is.read_uint32()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::color_rgb4_value(is.read_uint32()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::dimension_value_deprecated(is.read_float()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_value = ::std::option::Option::Some(Primitive_oneof_oneof_value::fraction_value_deprecated(is.read_float()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.oneof_value {
            match v {
                &Primitive_oneof_oneof_value::null_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Primitive_oneof_oneof_value::empty_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Primitive_oneof_oneof_value::float_value(v) => {
                    my_size += 5;
                },
                &Primitive_oneof_oneof_value::dimension_value(v) => {
                    my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::fraction_value(v) => {
                    my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::int_decimal_value(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::int_hexadecimal_value(v) => {
                    my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::boolean_value(v) => {
                    my_size += 2;
                },
                &Primitive_oneof_oneof_value::color_argb8_value(v) => {
                    my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::color_rgb8_value(v) => {
                    my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::color_argb4_value(v) => {
                    my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::color_rgb4_value(v) => {
                    my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Primitive_oneof_oneof_value::dimension_value_deprecated(v) => {
                    my_size += 5;
                },
                &Primitive_oneof_oneof_value::fraction_value_deprecated(v) => {
                    my_size += 5;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.oneof_value {
            match v {
                &Primitive_oneof_oneof_value::null_value(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Primitive_oneof_oneof_value::empty_value(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Primitive_oneof_oneof_value::float_value(v) => {
                    os.write_float(3, v)?;
                },
                &Primitive_oneof_oneof_value::dimension_value(v) => {
                    os.write_uint32(13, v)?;
                },
                &Primitive_oneof_oneof_value::fraction_value(v) => {
                    os.write_uint32(14, v)?;
                },
                &Primitive_oneof_oneof_value::int_decimal_value(v) => {
                    os.write_int32(6, v)?;
                },
                &Primitive_oneof_oneof_value::int_hexadecimal_value(v) => {
                    os.write_uint32(7, v)?;
                },
                &Primitive_oneof_oneof_value::boolean_value(v) => {
                    os.write_bool(8, v)?;
                },
                &Primitive_oneof_oneof_value::color_argb8_value(v) => {
                    os.write_uint32(9, v)?;
                },
                &Primitive_oneof_oneof_value::color_rgb8_value(v) => {
                    os.write_uint32(10, v)?;
                },
                &Primitive_oneof_oneof_value::color_argb4_value(v) => {
                    os.write_uint32(11, v)?;
                },
                &Primitive_oneof_oneof_value::color_rgb4_value(v) => {
                    os.write_uint32(12, v)?;
                },
                &Primitive_oneof_oneof_value::dimension_value_deprecated(v) => {
                    os.write_float(4, v)?;
                },
                &Primitive_oneof_oneof_value::fraction_value_deprecated(v) => {
                    os.write_float(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Primitive {
        Primitive::new()
    }

    fn default_instance() -> &'static Primitive {
        static instance: ::protobuf::rt::LazyV2<Primitive> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Primitive::new)
    }
}

impl ::protobuf::Clear for Primitive {
    fn clear(&mut self) {
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.oneof_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Primitive {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Primitive_NullType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Primitive_NullType {
    fn default() -> &'a Primitive_NullType {
        <Primitive_NullType as ::protobuf::Message>::default_instance()
    }
}

impl Primitive_NullType {
    pub fn new() -> Primitive_NullType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Primitive_NullType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Primitive_NullType {
        Primitive_NullType::new()
    }

    fn default_instance() -> &'static Primitive_NullType {
        static instance: ::protobuf::rt::LazyV2<Primitive_NullType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Primitive_NullType::new)
    }
}

impl ::protobuf::Clear for Primitive_NullType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Primitive_NullType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Primitive_EmptyType {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Primitive_EmptyType {
    fn default() -> &'a Primitive_EmptyType {
        <Primitive_EmptyType as ::protobuf::Message>::default_instance()
    }
}

impl Primitive_EmptyType {
    pub fn new() -> Primitive_EmptyType {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Primitive_EmptyType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Primitive_EmptyType {
        Primitive_EmptyType::new()
    }

    fn default_instance() -> &'static Primitive_EmptyType {
        static instance: ::protobuf::rt::LazyV2<Primitive_EmptyType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Primitive_EmptyType::new)
    }
}

impl ::protobuf::Clear for Primitive_EmptyType {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Primitive_EmptyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Attribute {
    // message fields
    pub format_flags: u32,
    pub min_int: i32,
    pub max_int: i32,
    pub symbol: ::protobuf::RepeatedField<Attribute_Symbol>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute {
    fn default() -> &'a Attribute {
        <Attribute as ::protobuf::Message>::default_instance()
    }
}

impl Attribute {
    pub fn new() -> Attribute {
        ::std::default::Default::default()
    }

    // uint32 format_flags = 1;


    pub fn get_format_flags(&self) -> u32 {
        self.format_flags
    }
    pub fn clear_format_flags(&mut self) {
        self.format_flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_format_flags(&mut self, v: u32) {
        self.format_flags = v;
    }

    // int32 min_int = 2;


    pub fn get_min_int(&self) -> i32 {
        self.min_int
    }
    pub fn clear_min_int(&mut self) {
        self.min_int = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_int(&mut self, v: i32) {
        self.min_int = v;
    }

    // int32 max_int = 3;


    pub fn get_max_int(&self) -> i32 {
        self.max_int
    }
    pub fn clear_max_int(&mut self) {
        self.max_int = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_int(&mut self, v: i32) {
        self.max_int = v;
    }

    // repeated .aapt.pb.Attribute.Symbol symbol = 4;


    pub fn get_symbol(&self) -> &[Attribute_Symbol] {
        &self.symbol
    }
    pub fn clear_symbol(&mut self) {
        self.symbol.clear();
    }

    // Param is passed by value, moved
    pub fn set_symbol(&mut self, v: ::protobuf::RepeatedField<Attribute_Symbol>) {
        self.symbol = v;
    }

    // Mutable pointer to the field.
    pub fn mut_symbol(&mut self) -> &mut ::protobuf::RepeatedField<Attribute_Symbol> {
        &mut self.symbol
    }

    // Take field
    pub fn take_symbol(&mut self) -> ::protobuf::RepeatedField<Attribute_Symbol> {
        ::std::mem::replace(&mut self.symbol, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Attribute {
    fn is_initialized(&self) -> bool {
        for v in &self.symbol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.format_flags = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_int = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_int = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.symbol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.format_flags != 0 {
            my_size += ::protobuf::rt::value_size(1, self.format_flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.min_int != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_int, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_int != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_int, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.symbol {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.format_flags != 0 {
            os.write_uint32(1, self.format_flags)?;
        }
        if self.min_int != 0 {
            os.write_int32(2, self.min_int)?;
        }
        if self.max_int != 0 {
            os.write_int32(3, self.max_int)?;
        }
        for v in &self.symbol {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute {
        Attribute::new()
    }

    fn default_instance() -> &'static Attribute {
        static instance: ::protobuf::rt::LazyV2<Attribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Attribute::new)
    }
}

impl ::protobuf::Clear for Attribute {
    fn clear(&mut self) {
        self.format_flags = 0;
        self.min_int = 0;
        self.max_int = 0;
        self.symbol.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Attribute_Symbol {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub name: ::protobuf::SingularPtrField<Reference>,
    pub value: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attribute_Symbol {
    fn default() -> &'a Attribute_Symbol {
        <Attribute_Symbol as ::protobuf::Message>::default_instance()
    }
}

impl Attribute_Symbol {
    pub fn new() -> Attribute_Symbol {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // .aapt.pb.Reference name = 3;


    pub fn get_name(&self) -> &Reference {
        self.name.as_ref().unwrap_or_else(|| <Reference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: Reference) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut Reference {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> Reference {
        self.name.take().unwrap_or_else(|| Reference::new())
    }

    // uint32 value = 4;


    pub fn get_value(&self) -> u32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }
}

impl ::protobuf::Message for Attribute_Symbol {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(4, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.value != 0 {
            os.write_uint32(4, self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attribute_Symbol {
        Attribute_Symbol::new()
    }

    fn default_instance() -> &'static Attribute_Symbol {
        static instance: ::protobuf::rt::LazyV2<Attribute_Symbol> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Attribute_Symbol::new)
    }
}

impl ::protobuf::Clear for Attribute_Symbol {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.name.clear();
        self.value = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute_Symbol {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Attribute_FormatFlags {
    NONE = 0,
    ANY = 65535,
    REFERENCE = 1,
    STRING = 2,
    INTEGER = 4,
    BOOLEAN = 8,
    COLOR = 16,
    FLOAT = 32,
    DIMENSION = 64,
    FRACTION = 128,
    ENUM = 65536,
    FLAGS = 131072,
}

impl ::protobuf::ProtobufEnum for Attribute_FormatFlags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Attribute_FormatFlags> {
        match value {
            0 => ::std::option::Option::Some(Attribute_FormatFlags::NONE),
            65535 => ::std::option::Option::Some(Attribute_FormatFlags::ANY),
            1 => ::std::option::Option::Some(Attribute_FormatFlags::REFERENCE),
            2 => ::std::option::Option::Some(Attribute_FormatFlags::STRING),
            4 => ::std::option::Option::Some(Attribute_FormatFlags::INTEGER),
            8 => ::std::option::Option::Some(Attribute_FormatFlags::BOOLEAN),
            16 => ::std::option::Option::Some(Attribute_FormatFlags::COLOR),
            32 => ::std::option::Option::Some(Attribute_FormatFlags::FLOAT),
            64 => ::std::option::Option::Some(Attribute_FormatFlags::DIMENSION),
            128 => ::std::option::Option::Some(Attribute_FormatFlags::FRACTION),
            65536 => ::std::option::Option::Some(Attribute_FormatFlags::ENUM),
            131072 => ::std::option::Option::Some(Attribute_FormatFlags::FLAGS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Attribute_FormatFlags] = &[
            Attribute_FormatFlags::NONE,
            Attribute_FormatFlags::ANY,
            Attribute_FormatFlags::REFERENCE,
            Attribute_FormatFlags::STRING,
            Attribute_FormatFlags::INTEGER,
            Attribute_FormatFlags::BOOLEAN,
            Attribute_FormatFlags::COLOR,
            Attribute_FormatFlags::FLOAT,
            Attribute_FormatFlags::DIMENSION,
            Attribute_FormatFlags::FRACTION,
            Attribute_FormatFlags::ENUM,
            Attribute_FormatFlags::FLAGS,
        ];
        values
    }
}

impl ::std::marker::Copy for Attribute_FormatFlags {
}

impl ::std::default::Default for Attribute_FormatFlags {
    fn default() -> Self {
        Attribute_FormatFlags::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Attribute_FormatFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Style {
    // message fields
    pub parent: ::protobuf::SingularPtrField<Reference>,
    pub parent_source: ::protobuf::SingularPtrField<Source>,
    pub entry: ::protobuf::RepeatedField<Style_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Style {
    fn default() -> &'a Style {
        <Style as ::protobuf::Message>::default_instance()
    }
}

impl Style {
    pub fn new() -> Style {
        ::std::default::Default::default()
    }

    // .aapt.pb.Reference parent = 1;


    pub fn get_parent(&self) -> &Reference {
        self.parent.as_ref().unwrap_or_else(|| <Reference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: Reference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut Reference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> Reference {
        self.parent.take().unwrap_or_else(|| Reference::new())
    }

    // .aapt.pb.Source parent_source = 2;


    pub fn get_parent_source(&self) -> &Source {
        self.parent_source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent_source(&mut self) {
        self.parent_source.clear();
    }

    pub fn has_parent_source(&self) -> bool {
        self.parent_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_source(&mut self, v: Source) {
        self.parent_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_source(&mut self) -> &mut Source {
        if self.parent_source.is_none() {
            self.parent_source.set_default();
        }
        self.parent_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_source(&mut self) -> Source {
        self.parent_source.take().unwrap_or_else(|| Source::new())
    }

    // repeated .aapt.pb.Style.Entry entry = 3;


    pub fn get_entry(&self) -> &[Style_Entry] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<Style_Entry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<Style_Entry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<Style_Entry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Style {
    fn is_initialized(&self) -> bool {
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent_source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent_source)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent_source.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.entry {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Style {
        Style::new()
    }

    fn default_instance() -> &'static Style {
        static instance: ::protobuf::rt::LazyV2<Style> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Style::new)
    }
}

impl ::protobuf::Clear for Style {
    fn clear(&mut self) {
        self.parent.clear();
        self.parent_source.clear();
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Style {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Style_Entry {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub key: ::protobuf::SingularPtrField<Reference>,
    pub item: ::protobuf::SingularPtrField<Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Style_Entry {
    fn default() -> &'a Style_Entry {
        <Style_Entry as ::protobuf::Message>::default_instance()
    }
}

impl Style_Entry {
    pub fn new() -> Style_Entry {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // .aapt.pb.Reference key = 3;


    pub fn get_key(&self) -> &Reference {
        self.key.as_ref().unwrap_or_else(|| <Reference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Reference) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Reference {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Reference {
        self.key.take().unwrap_or_else(|| Reference::new())
    }

    // .aapt.pb.Item item = 4;


    pub fn get_item(&self) -> &Item {
        self.item.as_ref().unwrap_or_else(|| <Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        self.item.take().unwrap_or_else(|| Item::new())
    }
}

impl ::protobuf::Message for Style_Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Style_Entry {
        Style_Entry::new()
    }

    fn default_instance() -> &'static Style_Entry {
        static instance: ::protobuf::rt::LazyV2<Style_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Style_Entry::new)
    }
}

impl ::protobuf::Clear for Style_Entry {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.key.clear();
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Style_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Styleable {
    // message fields
    pub entry: ::protobuf::RepeatedField<Styleable_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Styleable {
    fn default() -> &'a Styleable {
        <Styleable as ::protobuf::Message>::default_instance()
    }
}

impl Styleable {
    pub fn new() -> Styleable {
        ::std::default::Default::default()
    }

    // repeated .aapt.pb.Styleable.Entry entry = 1;


    pub fn get_entry(&self) -> &[Styleable_Entry] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<Styleable_Entry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<Styleable_Entry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<Styleable_Entry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Styleable {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Styleable {
        Styleable::new()
    }

    fn default_instance() -> &'static Styleable {
        static instance: ::protobuf::rt::LazyV2<Styleable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Styleable::new)
    }
}

impl ::protobuf::Clear for Styleable {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Styleable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Styleable_Entry {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub attr: ::protobuf::SingularPtrField<Reference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Styleable_Entry {
    fn default() -> &'a Styleable_Entry {
        <Styleable_Entry as ::protobuf::Message>::default_instance()
    }
}

impl Styleable_Entry {
    pub fn new() -> Styleable_Entry {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // .aapt.pb.Reference attr = 3;


    pub fn get_attr(&self) -> &Reference {
        self.attr.as_ref().unwrap_or_else(|| <Reference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attr(&mut self) {
        self.attr.clear();
    }

    pub fn has_attr(&self) -> bool {
        self.attr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr(&mut self, v: Reference) {
        self.attr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attr(&mut self) -> &mut Reference {
        if self.attr.is_none() {
            self.attr.set_default();
        }
        self.attr.as_mut().unwrap()
    }

    // Take field
    pub fn take_attr(&mut self) -> Reference {
        self.attr.take().unwrap_or_else(|| Reference::new())
    }
}

impl ::protobuf::Message for Styleable_Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        if let Some(ref v) = self.attr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        if let Some(ref v) = self.attr.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Styleable_Entry {
        Styleable_Entry::new()
    }

    fn default_instance() -> &'static Styleable_Entry {
        static instance: ::protobuf::rt::LazyV2<Styleable_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Styleable_Entry::new)
    }
}

impl ::protobuf::Clear for Styleable_Entry {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.attr.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Styleable_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Array {
    // message fields
    pub element: ::protobuf::RepeatedField<Array_Element>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Array {
    fn default() -> &'a Array {
        <Array as ::protobuf::Message>::default_instance()
    }
}

impl Array {
    pub fn new() -> Array {
        ::std::default::Default::default()
    }

    // repeated .aapt.pb.Array.Element element = 1;


    pub fn get_element(&self) -> &[Array_Element] {
        &self.element
    }
    pub fn clear_element(&mut self) {
        self.element.clear();
    }

    // Param is passed by value, moved
    pub fn set_element(&mut self, v: ::protobuf::RepeatedField<Array_Element>) {
        self.element = v;
    }

    // Mutable pointer to the field.
    pub fn mut_element(&mut self) -> &mut ::protobuf::RepeatedField<Array_Element> {
        &mut self.element
    }

    // Take field
    pub fn take_element(&mut self) -> ::protobuf::RepeatedField<Array_Element> {
        ::std::mem::replace(&mut self.element, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Array {
    fn is_initialized(&self) -> bool {
        for v in &self.element {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.element)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.element {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.element {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Array {
        Array::new()
    }

    fn default_instance() -> &'static Array {
        static instance: ::protobuf::rt::LazyV2<Array> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Array::new)
    }
}

impl ::protobuf::Clear for Array {
    fn clear(&mut self) {
        self.element.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Array {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Array_Element {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub item: ::protobuf::SingularPtrField<Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Array_Element {
    fn default() -> &'a Array_Element {
        <Array_Element as ::protobuf::Message>::default_instance()
    }
}

impl Array_Element {
    pub fn new() -> Array_Element {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // .aapt.pb.Item item = 3;


    pub fn get_item(&self) -> &Item {
        self.item.as_ref().unwrap_or_else(|| <Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        self.item.take().unwrap_or_else(|| Item::new())
    }
}

impl ::protobuf::Message for Array_Element {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Array_Element {
        Array_Element::new()
    }

    fn default_instance() -> &'static Array_Element {
        static instance: ::protobuf::rt::LazyV2<Array_Element> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Array_Element::new)
    }
}

impl ::protobuf::Clear for Array_Element {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Array_Element {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Plural {
    // message fields
    pub entry: ::protobuf::RepeatedField<Plural_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Plural {
    fn default() -> &'a Plural {
        <Plural as ::protobuf::Message>::default_instance()
    }
}

impl Plural {
    pub fn new() -> Plural {
        ::std::default::Default::default()
    }

    // repeated .aapt.pb.Plural.Entry entry = 1;


    pub fn get_entry(&self) -> &[Plural_Entry] {
        &self.entry
    }
    pub fn clear_entry(&mut self) {
        self.entry.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry(&mut self, v: ::protobuf::RepeatedField<Plural_Entry>) {
        self.entry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry(&mut self) -> &mut ::protobuf::RepeatedField<Plural_Entry> {
        &mut self.entry
    }

    // Take field
    pub fn take_entry(&mut self) -> ::protobuf::RepeatedField<Plural_Entry> {
        ::std::mem::replace(&mut self.entry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Plural {
    fn is_initialized(&self) -> bool {
        for v in &self.entry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Plural {
        Plural::new()
    }

    fn default_instance() -> &'static Plural {
        static instance: ::protobuf::rt::LazyV2<Plural> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Plural::new)
    }
}

impl ::protobuf::Clear for Plural {
    fn clear(&mut self) {
        self.entry.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Plural {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Plural_Entry {
    // message fields
    pub source: ::protobuf::SingularPtrField<Source>,
    pub comment: ::std::string::String,
    pub arity: Plural_Arity,
    pub item: ::protobuf::SingularPtrField<Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Plural_Entry {
    fn default() -> &'a Plural_Entry {
        <Plural_Entry as ::protobuf::Message>::default_instance()
    }
}

impl Plural_Entry {
    pub fn new() -> Plural_Entry {
        ::std::default::Default::default()
    }

    // .aapt.pb.Source source = 1;


    pub fn get_source(&self) -> &Source {
        self.source.as_ref().unwrap_or_else(|| <Source as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut Source {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Source {
        self.source.take().unwrap_or_else(|| Source::new())
    }

    // string comment = 2;


    pub fn get_comment(&self) -> &str {
        &self.comment
    }
    pub fn clear_comment(&mut self) {
        self.comment.clear();
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        &mut self.comment
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comment, ::std::string::String::new())
    }

    // .aapt.pb.Plural.Arity arity = 3;


    pub fn get_arity(&self) -> Plural_Arity {
        self.arity
    }
    pub fn clear_arity(&mut self) {
        self.arity = Plural_Arity::ZERO;
    }

    // Param is passed by value, moved
    pub fn set_arity(&mut self, v: Plural_Arity) {
        self.arity = v;
    }

    // .aapt.pb.Item item = 4;


    pub fn get_item(&self) -> &Item {
        self.item.as_ref().unwrap_or_else(|| <Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: Item) {
        self.item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut Item {
        if self.item.is_none() {
            self.item.set_default();
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> Item {
        self.item.take().unwrap_or_else(|| Item::new())
    }
}

impl ::protobuf::Message for Plural_Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comment)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.arity, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.comment.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.comment);
        }
        if self.arity != Plural_Arity::ZERO {
            my_size += ::protobuf::rt::enum_size(3, self.arity);
        }
        if let Some(ref v) = self.item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.comment.is_empty() {
            os.write_string(2, &self.comment)?;
        }
        if self.arity != Plural_Arity::ZERO {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.arity))?;
        }
        if let Some(ref v) = self.item.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Plural_Entry {
        Plural_Entry::new()
    }

    fn default_instance() -> &'static Plural_Entry {
        static instance: ::protobuf::rt::LazyV2<Plural_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Plural_Entry::new)
    }
}

impl ::protobuf::Clear for Plural_Entry {
    fn clear(&mut self) {
        self.source.clear();
        self.comment.clear();
        self.arity = Plural_Arity::ZERO;
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Plural_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Plural_Arity {
    ZERO = 0,
    ONE = 1,
    TWO = 2,
    FEW = 3,
    MANY = 4,
    OTHER = 5,
}

impl ::protobuf::ProtobufEnum for Plural_Arity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Plural_Arity> {
        match value {
            0 => ::std::option::Option::Some(Plural_Arity::ZERO),
            1 => ::std::option::Option::Some(Plural_Arity::ONE),
            2 => ::std::option::Option::Some(Plural_Arity::TWO),
            3 => ::std::option::Option::Some(Plural_Arity::FEW),
            4 => ::std::option::Option::Some(Plural_Arity::MANY),
            5 => ::std::option::Option::Some(Plural_Arity::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Plural_Arity] = &[
            Plural_Arity::ZERO,
            Plural_Arity::ONE,
            Plural_Arity::TWO,
            Plural_Arity::FEW,
            Plural_Arity::MANY,
            Plural_Arity::OTHER,
        ];
        values
    }
}

impl ::std::marker::Copy for Plural_Arity {
}

impl ::std::default::Default for Plural_Arity {
    fn default() -> Self {
        Plural_Arity::ZERO
    }
}

impl ::protobuf::reflect::ProtobufValue for Plural_Arity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct XmlNode {
    // message fields
    pub source: ::protobuf::SingularPtrField<SourcePosition>,
    // message oneof groups
    pub node: ::std::option::Option<XmlNode_oneof_node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XmlNode {
    fn default() -> &'a XmlNode {
        <XmlNode as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum XmlNode_oneof_node {
    element(XmlElement),
    text(::std::string::String),
}

impl XmlNode {
    pub fn new() -> XmlNode {
        ::std::default::Default::default()
    }

    // .aapt.pb.XmlElement element = 1;


    pub fn get_element(&self) -> &XmlElement {
        match self.node {
            ::std::option::Option::Some(XmlNode_oneof_node::element(ref v)) => v,
            _ => <XmlElement as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_element(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_element(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(XmlNode_oneof_node::element(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_element(&mut self, v: XmlElement) {
        self.node = ::std::option::Option::Some(XmlNode_oneof_node::element(v))
    }

    // Mutable pointer to the field.
    pub fn mut_element(&mut self) -> &mut XmlElement {
        if let ::std::option::Option::Some(XmlNode_oneof_node::element(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(XmlNode_oneof_node::element(XmlElement::new()));
        }
        match self.node {
            ::std::option::Option::Some(XmlNode_oneof_node::element(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_element(&mut self) -> XmlElement {
        if self.has_element() {
            match self.node.take() {
                ::std::option::Option::Some(XmlNode_oneof_node::element(v)) => v,
                _ => panic!(),
            }
        } else {
            XmlElement::new()
        }
    }

    // string text = 2;


    pub fn get_text(&self) -> &str {
        match self.node {
            ::std::option::Option::Some(XmlNode_oneof_node::text(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(XmlNode_oneof_node::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.node = ::std::option::Option::Some(XmlNode_oneof_node::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(XmlNode_oneof_node::text(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(XmlNode_oneof_node::text(::std::string::String::new()));
        }
        match self.node {
            ::std::option::Option::Some(XmlNode_oneof_node::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.node.take() {
                ::std::option::Option::Some(XmlNode_oneof_node::text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .aapt.pb.SourcePosition source = 3;


    pub fn get_source(&self) -> &SourcePosition {
        self.source.as_ref().unwrap_or_else(|| <SourcePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: SourcePosition) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut SourcePosition {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> SourcePosition {
        self.source.take().unwrap_or_else(|| SourcePosition::new())
    }
}

impl ::protobuf::Message for XmlNode {
    fn is_initialized(&self) -> bool {
        if let Some(XmlNode_oneof_node::element(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(XmlNode_oneof_node::element(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(XmlNode_oneof_node::text(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &XmlNode_oneof_node::element(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &XmlNode_oneof_node::text(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &XmlNode_oneof_node::element(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &XmlNode_oneof_node::text(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XmlNode {
        XmlNode::new()
    }

    fn default_instance() -> &'static XmlNode {
        static instance: ::protobuf::rt::LazyV2<XmlNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(XmlNode::new)
    }
}

impl ::protobuf::Clear for XmlNode {
    fn clear(&mut self) {
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.source.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for XmlNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct XmlElement {
    // message fields
    pub namespace_declaration: ::protobuf::RepeatedField<XmlNamespace>,
    pub namespace_uri: ::std::string::String,
    pub name: ::std::string::String,
    pub attribute: ::protobuf::RepeatedField<XmlAttribute>,
    pub child: ::protobuf::RepeatedField<XmlNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XmlElement {
    fn default() -> &'a XmlElement {
        <XmlElement as ::protobuf::Message>::default_instance()
    }
}

impl XmlElement {
    pub fn new() -> XmlElement {
        ::std::default::Default::default()
    }

    // repeated .aapt.pb.XmlNamespace namespace_declaration = 1;


    pub fn get_namespace_declaration(&self) -> &[XmlNamespace] {
        &self.namespace_declaration
    }
    pub fn clear_namespace_declaration(&mut self) {
        self.namespace_declaration.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace_declaration(&mut self, v: ::protobuf::RepeatedField<XmlNamespace>) {
        self.namespace_declaration = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namespace_declaration(&mut self) -> &mut ::protobuf::RepeatedField<XmlNamespace> {
        &mut self.namespace_declaration
    }

    // Take field
    pub fn take_namespace_declaration(&mut self) -> ::protobuf::RepeatedField<XmlNamespace> {
        ::std::mem::replace(&mut self.namespace_declaration, ::protobuf::RepeatedField::new())
    }

    // string namespace_uri = 2;


    pub fn get_namespace_uri(&self) -> &str {
        &self.namespace_uri
    }
    pub fn clear_namespace_uri(&mut self) {
        self.namespace_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace_uri(&mut self, v: ::std::string::String) {
        self.namespace_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace_uri(&mut self) -> &mut ::std::string::String {
        &mut self.namespace_uri
    }

    // Take field
    pub fn take_namespace_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace_uri, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .aapt.pb.XmlAttribute attribute = 4;


    pub fn get_attribute(&self) -> &[XmlAttribute] {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::protobuf::RepeatedField<XmlAttribute>) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::protobuf::RepeatedField<XmlAttribute> {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::protobuf::RepeatedField<XmlAttribute> {
        ::std::mem::replace(&mut self.attribute, ::protobuf::RepeatedField::new())
    }

    // repeated .aapt.pb.XmlNode child = 5;


    pub fn get_child(&self) -> &[XmlNode] {
        &self.child
    }
    pub fn clear_child(&mut self) {
        self.child.clear();
    }

    // Param is passed by value, moved
    pub fn set_child(&mut self, v: ::protobuf::RepeatedField<XmlNode>) {
        self.child = v;
    }

    // Mutable pointer to the field.
    pub fn mut_child(&mut self) -> &mut ::protobuf::RepeatedField<XmlNode> {
        &mut self.child
    }

    // Take field
    pub fn take_child(&mut self) -> ::protobuf::RepeatedField<XmlNode> {
        ::std::mem::replace(&mut self.child, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for XmlElement {
    fn is_initialized(&self) -> bool {
        for v in &self.namespace_declaration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.namespace_declaration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace_uri)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.namespace_declaration {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.namespace_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace_uri);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.child {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.namespace_declaration {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.namespace_uri.is_empty() {
            os.write_string(2, &self.namespace_uri)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.attribute {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.child {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XmlElement {
        XmlElement::new()
    }

    fn default_instance() -> &'static XmlElement {
        static instance: ::protobuf::rt::LazyV2<XmlElement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(XmlElement::new)
    }
}

impl ::protobuf::Clear for XmlElement {
    fn clear(&mut self) {
        self.namespace_declaration.clear();
        self.namespace_uri.clear();
        self.name.clear();
        self.attribute.clear();
        self.child.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for XmlElement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct XmlNamespace {
    // message fields
    pub prefix: ::std::string::String,
    pub uri: ::std::string::String,
    pub source: ::protobuf::SingularPtrField<SourcePosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XmlNamespace {
    fn default() -> &'a XmlNamespace {
        <XmlNamespace as ::protobuf::Message>::default_instance()
    }
}

impl XmlNamespace {
    pub fn new() -> XmlNamespace {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // string uri = 2;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }

    // .aapt.pb.SourcePosition source = 3;


    pub fn get_source(&self) -> &SourcePosition {
        self.source.as_ref().unwrap_or_else(|| <SourcePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: SourcePosition) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut SourcePosition {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> SourcePosition {
        self.source.take().unwrap_or_else(|| SourcePosition::new())
    }
}

impl ::protobuf::Message for XmlNamespace {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uri);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if !self.uri.is_empty() {
            os.write_string(2, &self.uri)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XmlNamespace {
        XmlNamespace::new()
    }

    fn default_instance() -> &'static XmlNamespace {
        static instance: ::protobuf::rt::LazyV2<XmlNamespace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(XmlNamespace::new)
    }
}

impl ::protobuf::Clear for XmlNamespace {
    fn clear(&mut self) {
        self.prefix.clear();
        self.uri.clear();
        self.source.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for XmlNamespace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct XmlAttribute {
    // message fields
    pub namespace_uri: ::std::string::String,
    pub name: ::std::string::String,
    pub value: ::std::string::String,
    pub source: ::protobuf::SingularPtrField<SourcePosition>,
    pub resource_id: u32,
    pub compiled_item: ::protobuf::SingularPtrField<Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XmlAttribute {
    fn default() -> &'a XmlAttribute {
        <XmlAttribute as ::protobuf::Message>::default_instance()
    }
}

impl XmlAttribute {
    pub fn new() -> XmlAttribute {
        ::std::default::Default::default()
    }

    // string namespace_uri = 1;


    pub fn get_namespace_uri(&self) -> &str {
        &self.namespace_uri
    }
    pub fn clear_namespace_uri(&mut self) {
        self.namespace_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespace_uri(&mut self, v: ::std::string::String) {
        self.namespace_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace_uri(&mut self) -> &mut ::std::string::String {
        &mut self.namespace_uri
    }

    // Take field
    pub fn take_namespace_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.namespace_uri, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value = 3;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // .aapt.pb.SourcePosition source = 4;


    pub fn get_source(&self) -> &SourcePosition {
        self.source.as_ref().unwrap_or_else(|| <SourcePosition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: SourcePosition) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut SourcePosition {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> SourcePosition {
        self.source.take().unwrap_or_else(|| SourcePosition::new())
    }

    // uint32 resource_id = 5;


    pub fn get_resource_id(&self) -> u32 {
        self.resource_id
    }
    pub fn clear_resource_id(&mut self) {
        self.resource_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_resource_id(&mut self, v: u32) {
        self.resource_id = v;
    }

    // .aapt.pb.Item compiled_item = 6;


    pub fn get_compiled_item(&self) -> &Item {
        self.compiled_item.as_ref().unwrap_or_else(|| <Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_compiled_item(&mut self) {
        self.compiled_item.clear();
    }

    pub fn has_compiled_item(&self) -> bool {
        self.compiled_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compiled_item(&mut self, v: Item) {
        self.compiled_item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compiled_item(&mut self) -> &mut Item {
        if self.compiled_item.is_none() {
            self.compiled_item.set_default();
        }
        self.compiled_item.as_mut().unwrap()
    }

    // Take field
    pub fn take_compiled_item(&mut self) -> Item {
        self.compiled_item.take().unwrap_or_else(|| Item::new())
    }
}

impl ::protobuf::Message for XmlAttribute {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compiled_item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.namespace_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.resource_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.compiled_item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.namespace_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace_uri);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.resource_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.resource_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.compiled_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.namespace_uri.is_empty() {
            os.write_string(1, &self.namespace_uri)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.resource_id != 0 {
            os.write_uint32(5, self.resource_id)?;
        }
        if let Some(ref v) = self.compiled_item.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XmlAttribute {
        XmlAttribute::new()
    }

    fn default_instance() -> &'static XmlAttribute {
        static instance: ::protobuf::rt::LazyV2<XmlAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(XmlAttribute::new)
    }
}

impl ::protobuf::Clear for XmlAttribute {
    fn clear(&mut self) {
        self.namespace_uri.clear();
        self.name.clear();
        self.value.clear();
        self.source.clear();
        self.resource_id = 0;
        self.compiled_item.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for XmlAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
